lungfish.matrix
trim.clad.dist.matrix(lungfish.matrix,lungfish.tree)
trim.out<-trim.clad.dist.matrix(lungfish.matrix,lungfish.tree)
dist.clad.matrix(lungfish.matrix)
lungfish.distances<-dist.clad.matrix(lungfish.matrix)
lungfish.distances
names(lungfish.distances)
lungfish.distances$dist.matrix/lungfish.distances$comp.char.matrix
Get distance matrices:#
lungfish.distances<-dist.clad.matrix(lungfish.matrix)#
#
# Get Gower dissimilarity matrix:#
lungfish.Gower<-lungfish.distances$dist.matrix/lungfish.distances$comp.char.matrix#
trim.clad.dist.matrix(lungfish.Gower,lungfish.tree)
trim.out<-trim.clad.dist.matrix(lungfish.Gower,lungfish.tree)
names(trim.out)
Give complete distance matrix:#
lungfish.Gower<-trim.out$dist.matrix#
#
# Get corresponding tree:#
lungfish.tree<-trim.out$tree
lungfish.Gower
Get in functions:#
source("http://www.graemetlloyd.com/pubdata/functions_3.r")#
#
# Library:#
library(phytools)#
#
# Read in a data matrix from my web site:#
lungfish.matrix<-get.nexus("http://www.graemetlloyd.com/nexus/Lloyd_etal_2012a.nex")#
#
# Read in tree:#
lungfish.tree<-read.tree("http://www.graemetlloyd.com/firstmpt/Lloyd_etal_2012a.tre")#
#
# Give tree arbitrary branch lengths for now (but should really time-scale):#
lungfish.tree$edge.length<-runif(length(lungfish.tree$edge[,1]),0,10)#
#
# Estimate ancestral state values:#
lungfish.ancestors<-anc.state.est.matrix(lungfish.matrix,lungfish.tree)#
#
# Rename active.anc.matrix rownames by descendant taxa that define them:#
for(j in 1:length(lungfish.ancestors[,1])) rownames(lungfish.ancestors)[j]<-paste(sort(lungfish.tree$tip.label[find.descendants(rownames(lungfish.ancestors)[j],lungfish.tree)]),collapse="%%")#
#
# Add ancestors into matrix:#
lungfish.matrix$matrix<-rbind(lungfish.matrix$matrix,lungfish.ancestors)#
#
# Get distance matrices:#
lungfish.distances<-dist.clad.matrix(lungfish.matrix)#
#
# Get Gower dissimilarity matrix:#
lungfish.Gower<-lungfish.distances$dist.matrix/lungfish.distances$comp.char.matrix#
#
# Trim taxa that cause missing data:#
trim.out<-trim.clad.dist.matrix(lungfish.Gower,lungfish.tree)#
#
# Give complete distance matrix:#
lungfish.Gower<-trim.out$dist.matrix#
#
# Get corresponding tree:#
lungfish.tree<-trim.out$tree
trim.out
Give complete distance matrix:#
lungfish.Gower<-trim.out$dist.matrix#
#
# Get corresponding tree:#
lungfish.tree<-trim.out$tree
Find node names:#
node.names<-rownames(lungfish.Gower)[grep("%%",rownames(lungfish.Gower))]#
#
# Find node numbers:#
for(j in 1:length(node.names)) names(node.names)[j]<-find.ancestor(strsplit(node.names[j],"%%")[[1]],lungfish.tree)#
#
# Replace node names with numbers:#
rownames(lungfish.Gower)[match(node.names,rownames(lungfish.Gower))]<-names(node.names)#
colnames(lungfish.Gower)[match(node.names,colnames(lungfish.Gower))]<-names(node.names)
lungfish.Gower
lungfish.tree
read.table("~/Documents/Teaching/External/PaleoDB Summer Course 2013/daterr.txt")
read.table("~/Documents/Teaching/External/PaleoDB Summer Course 2013/daterr.txt",row.names=TRUE)
read.table("~/Documents/Teaching/External/PaleoDB Summer Course 2013/daterr.txt",row.names=1)
ages<-read.table("~/Documents/Teaching/External/PaleoDB Summer Course 2013/daterr.txt",row.names=1)
rownames(ages)
match(lungfish.tree$tip.label,rownames(ages))
lungfish.tree$tip.label
sort(lungfish.tree$tip.label)
length(ages[,1])
Read in tree:#
lungfish.tree<-read.tree("http://www.graemetlloyd.com/firstmpt/Lloyd_etal_2012a.tre")
sort(lungfish.tree$tip.label)
Get in the necessary functions:#
source("http://www.graemetlloyd.com/pubdata/functions_3.r")#
#
# Library:#
library(phytools)#
#
# Read in a data matrix from my web site (pick a different one from this!):#
lungfish.matrix<-get.nexus("http://www.graemetlloyd.com/nexus/Lloyd_etal_2012a.nex")#
#
# Read in tree:#
lungfish.tree<-read.tree("http://www.graemetlloyd.com/firstmpt/Lloyd_etal_2012a.tre")#
ages<-read.table("~/Documents/Teaching/External/PaleoDB Summer Course 2013/daterr.txt",row.names=1)
match(lungfish.tree$tip.label,rownames(ages))
library(paleotree)
timePaleoPhy(lungfish.tree,ages)
timePaleoPhy(lungfish.tree,ages,type="equal",vartime=2)
Library:#
library(phytools)#
library(paleotree)#
#
# Read in a data matrix from my web site (pick a different one from this!):#
lungfish.matrix<-get.nexus("http://www.graemetlloyd.com/nexus/Lloyd_etal_2012a.nex")#
#
# Read in tree:#
lungfish.tree<-read.tree("http://www.graemetlloyd.com/firstmpt/Lloyd_etal_2012a.tre")#
lungfish.ages<-read.table("~/Documents/Teaching/External/PaleoDB Summer Course 2013/daterr.txt",row.names=1)#
timePaleoPhy(lungfish.tree,lungfish.ages,type="equal",vartime=5)
Get in the necessary functions:#
source("http://www.graemetlloyd.com/pubdata/functions_3.r")#
#
# Library:#
library(phytools)#
library(paleotree)#
#
# Read in a data matrix from my web site (pick a different one from this!):#
lungfish.matrix<-get.nexus("http://www.graemetlloyd.com/nexus/Lloyd_etal_2012a.nex")#
#
# Read in tree:#
lungfish.tree<-read.tree("http://www.graemetlloyd.com/firstmpt/Lloyd_etal_2012a.tre")#
#
# Read in ages:#
lungfish.ages<-read.table("~/Documents/Teaching/External/PaleoDB Summer Course 2013/daterr.txt",row.names=1)#
#
# Time-scale tree using equal method:#
lungfish.tree<-timePaleoPhy(lungfish.tree,lungfish.ages,type="equal",vartime=5)#
#
# Estimate ancestral state values:#
lungfish.ancestors<-anc.state.est.matrix(lungfish.matrix,lungfish.tree)#
#
# Rename ancestor rownames by descendant taxa that define them:#
for(j in 1:length(lungfish.ancestors[,1])) rownames(lungfish.ancestors)[j]<-paste(sort(lungfish.tree$tip.label[find.descendants(rownames(lungfish.ancestors)[j],lungfish.tree)]),collapse="%%")#
#
# Add ancestors into matrix:#
lungfish.matrix$matrix<-rbind(lungfish.matrix$matrix,lungfish.ancestors)#
#
# Get distance matrices:#
lungfish.distances<-dist.clad.matrix(lungfish.matrix)#
#
# Get Gower dissimilarity matrix:#
lungfish.Gower<-lungfish.distances$dist.matrix/lungfish.distances$comp.char.matrix#
#
# Trim taxa that cause missing data:#
trim.out<-trim.clad.dist.matrix(lungfish.Gower,lungfish.tree)#
#
# Only run the next two lines if you do not get the "There are no taxa to remove" warning:#
#
# Give complete distance matrix:#
lungfish.Gower<-trim.out$dist.matrix#
#
# Get corresponding tree:#
lungfish.tree<-trim.out$tree#
#
# Carry on after here if you did get the "There are no taxa to remove" warning:#
#
# Find node names:#
node.names<-rownames(lungfish.Gower)[grep("%%",rownames(lungfish.Gower))]#
for(j in 1:length(node.names)) names(node.names)[j]<-find.ancestor(strsplit(node.names[j],"%%")[[1]],lungfish.tree)#
rownames(lungfish.Gower)[match(node.names,rownames(lungfish.Gower))]<-names(node.names)#
colnames(lungfish.Gower)[match(node.names,colnames(lungfish.Gower))]<-names(node.names)#
#
# Perform principal coordinates on the data:#
pco<-cmdscale(lungfish.Gower,k=length(lungfish.Gower[,1])-1)
pco
plot(pco[,1],pco[,2],type="n")
pco[tree$edge[,1],1]
pco[lungfish.ttree$edge[,1],1]
pco[lungfish.tree$edge[,1],1]
pco[lungfish.tree$edge[,2],1]
pco[lungfish.tree$edge[,1],1]
plot(pco[,1],pco[,2],type="n")#
i<-1#
x<-c(pco[lungfish.tree$edge[,1][i],1],pco[lungfish.tree$edge[,2][i],1])#
y<-c(pco[lungfish.tree$edge[,1][i],2],pco[lungfish.tree$edge[,2][i],2])#
#
lines(x,y,col="grey")
x
y
lungfish.tree$edge[,1][i]
lungfish.tree$edge[,2][i]
plot(pco[,1],pco[,2],type="n")#
for(i in 1:length(lungfish.tree$edge.length)) {#
	x<-c(pco[lungfish.tree$edge[,1][i],1],pco[lungfish.tree$edge[,2][i],1])#
	y<-c(pco[lungfish.tree$edge[,1][i],2],pco[lungfish.tree$edge[,2][i],2])#
	lines(x,y,col="grey")#
}
plot.axis.1<-1#
plot.axis.2<-2#
plot(pco[,plot.axis.1],pco[,2],type="n")#
for(i in 1:length(lungfish.tree$edge.length)) {#
	x<-c(pco[lungfish.tree$edge[,1][i],plot.axis.1],pco[lungfish.tree$edge[,2][i],plot.axis.1])#
	y<-c(pco[lungfish.tree$edge[,1][i],plot.axis.2],pco[lungfish.tree$edge[,2][i],plot.axis.2])#
	lines(x,y,col="grey")#
}
plot.axis.1<-2#
plot.axis.2<-3#
plot(pco[,plot.axis.1],pco[,2],type="n")#
for(i in 1:length(lungfish.tree$edge.length)) {#
	x<-c(pco[lungfish.tree$edge[,1][i],plot.axis.1],pco[lungfish.tree$edge[,2][i],plot.axis.1])#
	y<-c(pco[lungfish.tree$edge[,1][i],plot.axis.2],pco[lungfish.tree$edge[,2][i],plot.axis.2])#
	lines(x,y,col="grey")#
}
plot.axis.1<-2#
plot.axis.2<-3#
plot(pco[,plot.axis.1],pco[,plot.axis.2],type="n")#
for(i in 1:length(lungfish.tree$edge.length)) {#
	x<-c(pco[lungfish.tree$edge[,1][i],plot.axis.1],pco[lungfish.tree$edge[,2][i],plot.axis.1])#
	y<-c(pco[lungfish.tree$edge[,1][i],plot.axis.2],pco[lungfish.tree$edge[,2][i],plot.axis.2])#
	lines(x,y,col="grey")#
}
plot.axis.1<-2#
plot.axis.2<-3#
plot(pco[,plot.axis.1],pco[,plot.axis.2],type="n")#
for(i in 1:length(lungfish.tree$edge.length)) {#
	x<-c(pco[lungfish.tree$edge[,1][i],plot.axis.1],pco[lungfish.tree$edge[,2][i],plot.axis.1])#
	y<-c(pco[lungfish.tree$edge[,1][i],plot.axis.2],pco[lungfish.tree$edge[,2][i],plot.axis.2])#
	lines(x,y,col="grey")#
}#
text(pco[,plot.axis.1],pco[,plot.axis.2],lungfish.tree$tip.label,cex=0.5)
anc.state.est.matrix
get.nexus("http://www.graemetlloyd.com/nexus/Boisserie_2005a.nex")
hippo<-get.nexus("http://www.graemetlloyd.com/nexus/Boisserie_2005a.nex")
hippo<-get.nexus("http://www.graemetlloyd.com/firstmpt/Boisserie_2005a.tre")
hippo<-read.tree("http://www.graemetlloyd.com/firstmpt/Boisserie_2005a.tre")
hippo$edge[,1]
length(hippo$edge[,1])
hippo$edge.length[1:length(hippo$edge[,1])]<-1
hippo.mat<-get.nexus("http://www.graemetlloyd.com/nexus/Boisserie_2005a.nex")
plot(hippo)
anc.state.est.matrix(hippo.mat,hippo)
anc.state.est.matrix
nexus.matrix<-hippo.mat
tree<-hippo
Requisite library:#
	require(phytools) # Must be version 0.2.63 or higher#
#
	# Create ancestral storage matrix:#
	anc.lik.matrix<-matrix(nrow=Nnode(tree),ncol=length(nexus.matrix$matrix[1,])) # Create matrix to record ancestral state estimates#
	rownames(anc.lik.matrix)<-c((Ntip(tree)+1):(Ntip(tree)+Nnode(tree))) # Label matrix to record ancestral state estimates#
#
	# For each character:#
	for(i in 1:length(nexus.matrix$matrix[1,])) { # Cycle through characters:#
#
		# Get minimum and maximum values for character:#
		minval<-nexus.matrix$min.vals[i]#
		maxval<-nexus.matrix$max.vals[i]#
		# Only proceed if character is variable:#
		if(maxval != minval) {#
#
            # If estimating states for all taxa then treat missing values as all possible states:#
            if(estimate.all) nexus.matrix$matrix[grep(TRUE,is.na(nexus.matrix$matrix[,i])),i]<-paste(minval:maxval,collapse="&")#
			# Find tips which cannot be used due to missing data:#
			tipstogo<-rownames(nexus.matrix$matrix)[grep(TRUE,is.na(nexus.matrix$matrix[,i]))] # Find taxa with missing data:#
#
			# If these exist remove them and create a pruned tree of just the taxa which can be coded:#
			if(length(tipstogo) > 0) chartree<-drop.tip(tree,tipstogo) # Remove tips with missing data#
			if(length(tipstogo) == 0) chartree<-tree # If no missing data use whole tree#
#
            # Only continue if at least three tips in pruned tree:#
            if(Ntip(chartree) > 2) {#
#
                # Get tip values for the pruned tree:#
                tipvals<-nexus.matrix$matrix[chartree$tip.label,i]#
#
                # Continue if not gap-coded (or apparently gap-coded) or is unordered:#
                if(!any(diff(sort(as.numeric(unlist(strsplit(tipvals,"&"))))) > 1) || nexus.matrix$ordering[i] == "UNORD") {#
#
                    # Set discrete character estimation model if unordered and or binary character:#
                    if(maxval-minval == 1 || maxval-minval > 1 && nexus.matrix$ordering[i] == "UNORD") mymodel<-"ER"#
#
                    # Set discrete character estimation model if ordered multistate character:#
                    if(maxval-minval > 1 && nexus.matrix$ordering[i] == "ORD") {#
#
                        # Create all zero matrix:#
                        mymodel<-matrix(0,nrow=(maxval-minval)+1,ncol=(maxval-minval)+1)#
#
                        # Name rows and columns as states:#
                        rownames(mymodel)<-colnames(mymodel)<-minval:maxval#
#
                        # Enter one for all the off-diagonal diagonals (an ordered change model:#
                        for(j in 1:(length(mymodel[1,])-1)) mymodel[j+1,j]<-mymodel[j,j+1]<-1#
                    }#
#
                    # Create matrix to store probabilities of tip values:#
                    tipvals.mat<-matrix(0,nrow=length(tipvals),ncol=maxval-minval+1)#
                    rownames(tipvals.mat)<-names(tipvals)#
                    colnames(tipvals.mat)<-minval:maxval#
#
                    # Fill all probabilities equal to one (non-polymorphisms):#
                    for(j in colnames(tipvals.mat)) tipvals.mat[grep(TRUE,tipvals == j),j]<-1#
#
                    # If there are polymorphisms make all observed states equally probable:#
                    if(any(apply(tipvals.mat,1,sum) == 0)) {#
#
                        # Get list of tip values with polymorphisms:#
                        polymorphism.values<-grep(TRUE,apply(tipvals.mat,1,sum) == 0)#
#
                        # Go through each polymorphism:#
                        for(j in polymorphism.values) {#
                            # Get list of each state:#
                            states<-strsplit(tipvals[j],"&")[[1]]#
#
                            # Make each state equally probable in tip values matrix:#
                            tipvals.mat[j,states]<-1/length(states)#
                        }#
                    }#
#
                    # Get likelihoods for each state in taxa and ancestors:#
                    state.likelihoods<-rerootingMethod(chartree,tipvals.mat,model=mymodel)$marginal.anc#
#
                    # Get maximum likelihood:#
                    max.lik<-apply(state.likelihoods,1,max)#
#
                    # Vector to store maximum likelihood states:#
                    max.lik.state<-vector(mode="character",length=length(rownames(state.likelihoods)))#
                    names(max.lik.state)<-rownames(state.likelihoods)#
#
                    # For each tip and node find most likely state(s):#
                    for(j in 1:length(max.lik)) max.lik.state[j]<-paste(colnames(state.likelihoods)[grep(TRUE,state.likelihoods[j,] == max.lik[j])],collapse="&")#
#
                } else { # Case if gap-coded or apparently gap-coded:#
                    # If there are polymorphisms present:#
                    if(length(grep("&",tipvals)) > 0) {#
#
                        # List rows with ;olymorphisms:#
                        rows<-grep("&",tipvals)#
#
                        # For each polymorphism:#
                        for(j in 1:length(rows)) {#
                            # Replace polymorphisms with mean values:#
                            tipvals[rows[j]]<-mean(as.numeric(strsplit(tipvals[rows[j]],"&")[[1]]))#
                        }#
                    }#
#
                    # Treat character as continuous to get ancestral state estimates:#
                    max.lik.state<-round(ace(as.numeric(tipvals),chartree)$ace)#
                }#
                # Get node numbers for pruned tree:#
                chartreenodes<-(Ntip(chartree)+1):(Ntip(chartree)+Nnode(chartree)) # Nodes for character tree#
#
                # For each node on pruned tree:#
                for(j in chartreenodes) {#
#
                    # Find descendants in pruned tree:#
                    descs<-sort(chartree$tip.label[find.descendants(j,chartree)])#
#
                    # Store ancestral values in state estimation matrix:#
                    anc.lik.matrix[as.character(find.ancestor(descs,tree)),i]<-max.lik.state[as.character(j)]#
                }#
#
			} # Case if pruned tree too small to inform (leave matrix as NAs)#
#
		} else { # Case if constant character:#
#
			# Enter constant value for all nodes:#
			anc.lik.matrix[,i]<-minval#
		}#
	}
estimate.all<-FALSE
Requisite library:#
	require(phytools) # Must be version 0.2.63 or higher#
#
	# Create ancestral storage matrix:#
	anc.lik.matrix<-matrix(nrow=Nnode(tree),ncol=length(nexus.matrix$matrix[1,])) # Create matrix to record ancestral state estimates#
	rownames(anc.lik.matrix)<-c((Ntip(tree)+1):(Ntip(tree)+Nnode(tree))) # Label matrix to record ancestral state estimates#
#
	# For each character:#
	for(i in 1:length(nexus.matrix$matrix[1,])) { # Cycle through characters:#
#
		# Get minimum and maximum values for character:#
		minval<-nexus.matrix$min.vals[i]#
		maxval<-nexus.matrix$max.vals[i]#
		# Only proceed if character is variable:#
		if(maxval != minval) {#
#
            # If estimating states for all taxa then treat missing values as all possible states:#
            if(estimate.all) nexus.matrix$matrix[grep(TRUE,is.na(nexus.matrix$matrix[,i])),i]<-paste(minval:maxval,collapse="&")#
			# Find tips which cannot be used due to missing data:#
			tipstogo<-rownames(nexus.matrix$matrix)[grep(TRUE,is.na(nexus.matrix$matrix[,i]))] # Find taxa with missing data:#
#
			# If these exist remove them and create a pruned tree of just the taxa which can be coded:#
			if(length(tipstogo) > 0) chartree<-drop.tip(tree,tipstogo) # Remove tips with missing data#
			if(length(tipstogo) == 0) chartree<-tree # If no missing data use whole tree#
#
            # Only continue if at least three tips in pruned tree:#
            if(Ntip(chartree) > 2) {#
#
                # Get tip values for the pruned tree:#
                tipvals<-nexus.matrix$matrix[chartree$tip.label,i]#
#
                # Continue if not gap-coded (or apparently gap-coded) or is unordered:#
                if(!any(diff(sort(as.numeric(unlist(strsplit(tipvals,"&"))))) > 1) || nexus.matrix$ordering[i] == "UNORD") {#
#
                    # Set discrete character estimation model if unordered and or binary character:#
                    if(maxval-minval == 1 || maxval-minval > 1 && nexus.matrix$ordering[i] == "UNORD") mymodel<-"ER"#
#
                    # Set discrete character estimation model if ordered multistate character:#
                    if(maxval-minval > 1 && nexus.matrix$ordering[i] == "ORD") {#
#
                        # Create all zero matrix:#
                        mymodel<-matrix(0,nrow=(maxval-minval)+1,ncol=(maxval-minval)+1)#
#
                        # Name rows and columns as states:#
                        rownames(mymodel)<-colnames(mymodel)<-minval:maxval#
#
                        # Enter one for all the off-diagonal diagonals (an ordered change model:#
                        for(j in 1:(length(mymodel[1,])-1)) mymodel[j+1,j]<-mymodel[j,j+1]<-1#
                    }#
#
                    # Create matrix to store probabilities of tip values:#
                    tipvals.mat<-matrix(0,nrow=length(tipvals),ncol=maxval-minval+1)#
                    rownames(tipvals.mat)<-names(tipvals)#
                    colnames(tipvals.mat)<-minval:maxval#
#
                    # Fill all probabilities equal to one (non-polymorphisms):#
                    for(j in colnames(tipvals.mat)) tipvals.mat[grep(TRUE,tipvals == j),j]<-1#
#
                    # If there are polymorphisms make all observed states equally probable:#
                    if(any(apply(tipvals.mat,1,sum) == 0)) {#
#
                        # Get list of tip values with polymorphisms:#
                        polymorphism.values<-grep(TRUE,apply(tipvals.mat,1,sum) == 0)#
#
                        # Go through each polymorphism:#
                        for(j in polymorphism.values) {#
                            # Get list of each state:#
                            states<-strsplit(tipvals[j],"&")[[1]]#
#
                            # Make each state equally probable in tip values matrix:#
                            tipvals.mat[j,states]<-1/length(states)#
                        }#
                    }#
#
                    # Get likelihoods for each state in taxa and ancestors:#
                    state.likelihoods<-rerootingMethod(chartree,tipvals.mat,model=mymodel)$marginal.anc#
#
                    # Get maximum likelihood:#
                    max.lik<-apply(state.likelihoods,1,max)#
#
                    # Vector to store maximum likelihood states:#
                    max.lik.state<-vector(mode="character",length=length(rownames(state.likelihoods)))#
                    names(max.lik.state)<-rownames(state.likelihoods)#
#
                    # For each tip and node find most likely state(s):#
                    for(j in 1:length(max.lik)) max.lik.state[j]<-paste(colnames(state.likelihoods)[grep(TRUE,state.likelihoods[j,] == max.lik[j])],collapse="&")#
#
                } else { # Case if gap-coded or apparently gap-coded:#
                    # If there are polymorphisms present:#
                    if(length(grep("&",tipvals)) > 0) {#
#
                        # List rows with ;olymorphisms:#
                        rows<-grep("&",tipvals)#
#
                        # For each polymorphism:#
                        for(j in 1:length(rows)) {#
                            # Replace polymorphisms with mean values:#
                            tipvals[rows[j]]<-mean(as.numeric(strsplit(tipvals[rows[j]],"&")[[1]]))#
                        }#
                    }#
#
                    # Treat character as continuous to get ancestral state estimates:#
                    max.lik.state<-round(ace(as.numeric(tipvals),chartree)$ace)#
                }#
                # Get node numbers for pruned tree:#
                chartreenodes<-(Ntip(chartree)+1):(Ntip(chartree)+Nnode(chartree)) # Nodes for character tree#
#
                # For each node on pruned tree:#
                for(j in chartreenodes) {#
#
                    # Find descendants in pruned tree:#
                    descs<-sort(chartree$tip.label[find.descendants(j,chartree)])#
#
                    # Store ancestral values in state estimation matrix:#
                    anc.lik.matrix[as.character(find.ancestor(descs,tree)),i]<-max.lik.state[as.character(j)]#
                }#
#
			} # Case if pruned tree too small to inform (leave matrix as NAs)#
#
		} else { # Case if constant character:#
#
			# Enter constant value for all nodes:#
			anc.lik.matrix[,i]<-minval#
		}#
	}
i
minval
maxval
chartree
tipstogo
tipvals
i<-1
tipstogo<-rownames(nexus.matrix$matrix)[grep(TRUE,is.na(nexus.matrix$matrix[,i]))] # Find taxa with missing data:#
        if(length(tipstogo) > 0) chartree<-drop.tip(tree,tipstogo) # Remove tips with missing data#
        if(length(tipstogo) == 0) chartree<-tree # If no missing data use whole tree    #
        tipvals<-nexus.matrix$matrix[chartree$tip.label,i]#
        # Create state change matrix (important for ordered/unordered characters:#
        minval<-as.numeric(nexus.matrix$min.vals[i])#
        maxval<-as.numeric(nexus.matrix$max.vals[i])#
        if(maxval-minval == 1) mymodel<-matrix(c(minval,maxval,maxval,minval),2) # Case for binary character (ordering irrelevant)#
        if(maxval-minval > 1 && nexus.matrix$ordering[i] == "UNORD") { # Case for unordered multistate character#
            mymodel<-matrix(1,ncol=(maxval-minval)+1,nrow=(maxval-minval)+1)#
            for(j in 1:length(mymodel[1,])) mymodel[j,j]<-0#
        }
if(maxval-minval > 1 && nexus.matrix$ordering[i] == "ORD") { # Case for ordered multistate character#
            mymodel<-matrix(0,ncol=(maxval-minval)+1,nrow=(maxval-minval)+1)#
            for(j in 1:length(mymodel[1,])) {#
                for(k in 1:length(mymodel[1,])) {#
                    mymodel[j,k]<-sqrt((diff(c(j,k)))^2)#
                }#
            }#
        }
mymodel
Ascertain if polymorphisms are present and if so compute all possible prmutations#
        if(length(grep("&",tipvals)) > 0) {#
            permutation.counts<-vector(mode="numeric") # Vector to store permutation numbers for each taxon (i.e. number of possible states)#
            for(j in 1:length(tipvals)) permutation.counts[j]<-length(strsplit(as.character(tipvals[j]),"&")[[1]]) # Get number of permutations for each taxon#
            permutation.count<-prod(permutation.counts) # Get product of permutation counts (i.e. total number of permutations)#
            permutations<-matrix(nrow=length(tipvals),ncol=permutation.count) # Make permutations matrix#
            permutations[grep(TRUE,permutation.counts == 1),1:permutation.count]<-as.numeric(tipvals[grep(TRUE,permutation.counts == 1)]) # Fill in data for non-polymorphic characters#
            phase.count<-1 # Permutation phase#
            for(j in grep("&",tipvals)) {#
                perm<-as.numeric(strsplit(as.character(tipvals[j]),"&")[[1]])#
                if(phase.count == 1) permutations[j,]<-perm#
                if(phase.count > 1) {#
                    perm<-sort(rep(perm,phase.count))#
                    permutations[j,]<-perm#
                }#
                phase.count<-length(perm)#
            }#
            rownames(permutations)<-names(tipvals) # Make sure tip value names are carried over#
            # Ancestor state estimate for first permutation:#
            if(length(unique(sort(permutations[,1]))) > 1) { # If there is more than one state#
                if(length(mymodel[,1]) > length(sort(unique(as.numeric(permutations[,1]))))) { # Case if model has larger spread than actual tipvalues (e.g. spans 0-5 when 2 is not recorded)#
                    anc.lik<-ace(permutations[,1],chartree,type="discrete",model=mymodel[sort(unique(as.numeric(permutations[,1])))+1,sort(unique(as.numeric(permutations[,1])))+1])$lik.anc#
                }#
                if(length(mymodel[,1]) <= length(sort(unique(as.numeric(permutations[,1]))))) { # Case if model has same spread as tip values (theoretically this should always be true, but in reality not so much)#
                    anc.lik<-ace(permutations[,1],chartree,type="discrete",model=mymodel[])$lik.anc#
                }#
            }#
            if(length(unique(sort(permutations[,1]))) == 1) {#
                anc.lik<-matrix(0,nrow=length(permutations[,1])-1,ncol=max(c((unique(sort(as.numeric(permutations[,1])))+1),2)))#
                colnames(anc.lik)<-c(0:max(c(unique(sort(as.numeric(permutations[,1]))),1)))#
                anc.lik[,as.character(unique(sort(as.numeric(permutations[,1]))))]<-rep(1,length(permutations[,1])-1)#
            }#
            for(j in 2:length(permutations[1,])) { # Cycle through remaining permutations#
                if(length(unique(sort(permutations[,j]))) > 1) {#
                    if(length(mymodel[,1]) > length(sort(unique(as.numeric(permutations[,j]))))) { # Case if model has larger spread than actual tipvalues (e.g. spans 0-5 when 2 is not recorded)#
                        anc.lik<-((anc.lik*(j-1))+ace(permutations[,j],chartree,type="discrete",model=mymodel[sort(unique(as.numeric(permutations[,j])))+1,sort(unique(as.numeric(permutations[,j])))+1])$lik.anc)/j # Get mean ancestral estimations#
                    }#
                    if(length(mymodel[,1]) <= length(sort(unique(as.numeric(permutations[,j]))))) { # Case if model has same spread as tip values (theoretically this should always be true, but in reality not so much)#
                        anc.lik<-((anc.lik*(j-1))+ace(permutations[,j],chartree,type="discrete",model=mymodel)$lik.anc)/j # Get mean ancestral estimations#
                    }#
                }#
                if(length(unique(sort(permutations[,j]))) == 1) {#
                    anc.lik.perm<-matrix(0,nrow=length(permutations[,j])-1,ncol=max(c((unique(sort(as.numeric(permutations[,j])))+1),2)))#
                    colnames(anc.lik.perm)<-c(0:max(c(unique(sort(as.numeric(permutations[,j]))),1)))#
                    anc.lik.perm[,as.character(unique(sort(as.numeric(permutations[,j]))))]<-rep(1,length(permutations[,j])-1)#
                    anc.lik<-((anc.lik*(j-1))+anc.lik.perm)/j # Get mean ancestral estimations#
                }#
            }#
        }
length(grep("&",tipvals)) == 0 && length(unique(sort(as.numeric(tipvals)))) > 1
if(length(mymodel[,1]) > length(sort(unique(as.numeric(tipvals))))) { # Case if model has larger spread than actual tipvalues (e.g. spans 0-5 when 2 is not recorded)#
                anc.lik<-ace(as.numeric(tipvals),chartree,type="discrete",model=mymodel[sort(unique(as.numeric(tipvals)))+1,sort(unique(as.numeric(tipvals)))+1])$lik.anc # Get ancestral state likelihoods for internal nodes#
            }#
            if(length(mymodel[,1]) <= length(sort(unique(as.numeric(tipvals))))) { # Case if model has same spread as tip values (theoretically this should always be true, but in reality not so much)#
                anc.lik<-ace(as.numeric(tipvals),chartree,type="discrete",model=mymodel)$lik.anc # Get ancestral state likelihoods for internal nodes#
            }
plot(tree)
read.tree("http://www.graemetlloyd.com/firstmpt/Sterli_et_De_La_Fuente_2011a.tre")
library(ape)
read.tree("http://www.graemetlloyd.com/firstmpt/Sterli_et_De_La_Fuente_2011a.tre")
Get in the necessary functions:#
source("http://www.graemetlloyd.com/pubdata/functions_3.r")#
#
# Library:#
library(phytools)#
library(paleotree)#
#
# Read in a data matrix from my web site (pick a different one from this!):#
lungfish.matrix<-get.nexus("http://www.graemetlloyd.com/nexus/Lloyd_etal_2012a.nex")#
#
# Read in tree:#
lungfish.tree<-read.tree("http://www.graemetlloyd.com/firstmpt/Lloyd_etal_2012a.tre")#
#
# Read in ages:#
lungfish.ages<-read.table("~/Documents/Teaching/External/PaleoDB Summer Course 2013/daterr.txt",row.names=1)#
#
# Time-scale tree using equal method:#
lungfish.tree<-timePaleoPhy(lungfish.tree,lungfish.ages,type="equal",vartime=5)#
#
# Estimate ancestral state values:#
lungfish.ancestors<-anc.state.est.matrix(lungfish.matrix,lungfish.tree)#
#
# Rename ancestor rownames by descendant taxa that define them:#
for(j in 1:length(lungfish.ancestors[,1])) rownames(lungfish.ancestors)[j]<-paste(sort(lungfish.tree$tip.label[find.descendants(rownames(lungfish.ancestors)[j],lungfish.tree)]),collapse="%%")#
#
# Add ancestors into matrix:#
lungfish.matrix$matrix<-rbind(lungfish.matrix$matrix,lungfish.ancestors)#
#
# Get distance matrices:#
lungfish.distances<-dist.clad.matrix(lungfish.matrix)#
#
# Get Gower dissimilarity matrix:#
lungfish.Gower<-lungfish.distances$dist.matrix/lungfish.distances$comp.char.matrix#
#
# Trim taxa that cause missing data:#
trim.out<-trim.clad.dist.matrix(lungfish.Gower,lungfish.tree)#
#
# Only run the next two lines if you do not get the "There are no taxa to remove" warning:#
#
# Give complete distance matrix:#
lungfish.Gower<-trim.out$dist.matrix#
#
# Get corresponding tree:#
lungfish.tree<-trim.out$tree#
#
# Carry on after here if you did get the "There are no taxa to remove" warning:#
#
# Find node names:#
node.names<-rownames(lungfish.Gower)[grep("%%",rownames(lungfish.Gower))]#
for(j in 1:length(node.names)) names(node.names)[j]<-find.ancestor(strsplit(node.names[j],"%%")[[1]],lungfish.tree)#
rownames(lungfish.Gower)[match(node.names,rownames(lungfish.Gower))]<-names(node.names)#
colnames(lungfish.Gower)[match(node.names,colnames(lungfish.Gower))]<-names(node.names)#
#
# Perform principal coordinates on the data:#
pco<-cmdscale(lungfish.Gower,k=length(lungfish.Gower[,1])-1)#
plot.axis.1<-2#
plot.axis.2<-3#
plot(pco[,plot.axis.1],pco[,plot.axis.2],type="n")#
for(i in 1:length(lungfish.tree$edge.length)) {#
	x<-c(pco[lungfish.tree$edge[,1][i],plot.axis.1],pco[lungfish.tree$edge[,2][i],plot.axis.1])#
	y<-c(pco[lungfish.tree$edge[,1][i],plot.axis.2],pco[lungfish.tree$edge[,2][i],plot.axis.2])#
	lines(x,y,col="grey")#
}#
text(pco[,plot.axis.1],pco[,plot.axis.2],lungfish.tree$tip.label,cex=0.5)
plot.axis.1<-2#
plot.axis.2<-3#
plot(pco[,plot.axis.1],pco[,plot.axis.2],type="n")#
for(i in 1:length(lungfish.tree$edge.length)) {#
	x<-c(pco[lungfish.tree$edge[,1][i],plot.axis.1],pco[lungfish.tree$edge[,2][i],plot.axis.1])#
	y<-c(pco[lungfish.tree$edge[,1][i],plot.axis.2],pco[lungfish.tree$edge[,2][i],plot.axis.2])#
	lines(x,y,col="grey")#
}#
points(pco[1:Ntip(lungfish.tree),plot.axis.1],pco[1:Ntip(lungfish.tree),plot.axis.2],pch=4)
plot.axis.1<-1#
plot.axis.2<-2#
plot(pco[,plot.axis.1],pco[,plot.axis.2],type="n")#
for(i in 1:length(lungfish.tree$edge.length)) {#
	x<-c(pco[lungfish.tree$edge[,1][i],plot.axis.1],pco[lungfish.tree$edge[,2][i],plot.axis.1])#
	y<-c(pco[lungfish.tree$edge[,1][i],plot.axis.2],pco[lungfish.tree$edge[,2][i],plot.axis.2])#
	lines(x,y,col="grey")#
}#
points(pco[1:Ntip(lungfish.tree),plot.axis.1],pco[1:Ntip(lungfish.tree),plot.axis.2],pch=4)
apply(pco,2,var)
apply(pco,2,var)/sum(apply(pco,2,var))
apply(pco,2,var)/sum(apply(pco,2,var))*100
Perform principal coordinates on the data:#
pco<-cmdscale(lungfish.Gower,k=length(lungfish.Gower[,1])-1)#
#
# Get variance of pco axes:#
pco.variances<-apply(pco,2,var)/sum(apply(pco,2,var))*100
plot(pco.variances)
plot(pco.variances,type="l")
plot.axis.1<-1#
plot.axis.2<-2#
plot(pco[,plot.axis.1],pco[,plot.axis.2],type="n")#
for(i in 1:length(lungfish.tree$edge.length)) {#
	x<-c(pco[lungfish.tree$edge[,1][i],plot.axis.1],pco[lungfish.tree$edge[,2][i],plot.axis.1])#
	y<-c(pco[lungfish.tree$edge[,1][i],plot.axis.2],pco[lungfish.tree$edge[,2][i],plot.axis.2])#
	lines(x,y,col="grey")#
}#
points(pco[1:Ntip(lungfish.tree),plot.axis.1],pco[1:Ntip(lungfish.tree),plot.axis.2],pch=4)
lungfish.tree$tip.label
rownames(lungfish.Gower)
lungfish.Gower[lungfish.tree$tip.label,]
lungfish.Gower[1:length(lungfish.tree$tip.label),]
lungfish.Gower[1:length(lungfish.tree$tip.label),]<-lungfish.Gower[lungfish.tree$tip.label,]#
# Get variance of pco axes:#
pco.variances<-apply(pco,2,var)/sum(apply(pco,2,var))*100#
plot.axis.1<-1#
plot.axis.2<-2#
plot(pco[,plot.axis.1],pco[,plot.axis.2],type="n")#
for(i in 1:length(lungfish.tree$edge.length)) {#
	x<-c(pco[lungfish.tree$edge[,1][i],plot.axis.1],pco[lungfish.tree$edge[,2][i],plot.axis.1])#
	y<-c(pco[lungfish.tree$edge[,1][i],plot.axis.2],pco[lungfish.tree$edge[,2][i],plot.axis.2])#
	lines(x,y,col="grey")#
}#
points(pco[1:Ntip(lungfish.tree),plot.axis.1],pco[1:Ntip(lungfish.tree),plot.axis.2],pch=4)
plot.axis.1<-2#
plot.axis.2<-3#
plot(pco[,plot.axis.1],pco[,plot.axis.2],type="n")#
for(i in 1:length(lungfish.tree$edge.length)) {#
	x<-c(pco[lungfish.tree$edge[,1][i],plot.axis.1],pco[lungfish.tree$edge[,2][i],plot.axis.1])#
	y<-c(pco[lungfish.tree$edge[,1][i],plot.axis.2],pco[lungfish.tree$edge[,2][i],plot.axis.2])#
	lines(x,y,col="grey")#
}#
points(pco[1:Ntip(lungfish.tree),plot.axis.1],pco[1:Ntip(lungfish.tree),plot.axis.2],pch=4)
lungfish.tree$edge[,1]
lungfish.tree$edge[i,2]
lungfish.tree$edge[i,2] <= Ntip(lungfish.tree)
lungfish.tree$tip.label[lungfish.tree$edge[i,2]]
match(lungfish.tree$tip.label[lungfish.tree$edge[i,2]],rownames(lungfish.Gower))
match(lungfish.tree$tip.label[lungfish.tree$edge[i,1]],rownames(lungfish.Gower))
match(as.character(lungfish.tree$tip.label[lungfish.tree$edge[i,1]]),rownames(lungfish.Gower))
match(lungfish.tree$edge[i,1],rownames(lungfish.Gower))
lungfish.tree$edge[i,1]
match(as.character(lungfish.tree$edge[i,1]),rownames(lungfish.Gower))
from.row<-match(as.character(lungfish.tree$edge[i,1]),rownames(lungfish.Gower))#
	# If this is a terminal branch:#
	if(lungfish.tree$edge[i,2] <= Ntip(lungfish.tree)) {#
		to.row<-match(lungfish.tree$tip.label[lungfish.tree$edge[i,2]],rownames(lungfish.Gower))#
	} else {#
		to.row<-match(as.character(lungfish.tree$edge[i,2]),rownames(lungfish.Gower))#
	}
from.row
to.row
plot.axis.1<-2#
plot.axis.2<-3#
plot(pco[,plot.axis.1],pco[,plot.axis.2],type="n")#
for(i in 1:length(lungfish.tree$edge.length)) {#
#
	from.row<-match(as.character(lungfish.tree$edge[i,1]),rownames(lungfish.Gower))#
	# If this is a terminal branch:#
	if(lungfish.tree$edge[i,2] <= Ntip(lungfish.tree)) {#
		to.row<-match(lungfish.tree$tip.label[lungfish.tree$edge[i,2]],rownames(lungfish.Gower))#
	} else {#
		to.row<-match(as.character(lungfish.tree$edge[i,2]),rownames(lungfish.Gower))#
	}#
	x<-c(pco[from.row,plot.axis.1],pco[to.row,plot.axis.1])#
	y<-c(pco[from.row,plot.axis.2],pco[to.row,plot.axis.2])#
#
	lines(x,y,col="grey")#
}
plot.axis.1<-2#
plot.axis.2<-3#
plot(pco[,plot.axis.1],pco[,plot.axis.2],type="n")#
for(i in 1:length(lungfish.tree$edge.length)) {#
#
	from.row<-match(as.character(lungfish.tree$edge[i,1]),rownames(lungfish.Gower))#
	# If this is a terminal branch:#
	if(lungfish.tree$edge[i,2] <= Ntip(lungfish.tree)) {#
		to.row<-match(lungfish.tree$tip.label[lungfish.tree$edge[i,2]],rownames(lungfish.Gower))#
	} else {#
		to.row<-match(as.character(lungfish.tree$edge[i,2]),rownames(lungfish.Gower))#
	}#
	x<-c(pco[from.row,plot.axis.1],pco[to.row,plot.axis.1])#
	y<-c(pco[from.row,plot.axis.2],pco[to.row,plot.axis.2])#
#
	lines(x,y,col="grey")#
}#
points(pco[1:Ntip(lungfish.tree),plot.axis.1],pco[1:Ntip(lungfish.tree),plot.axis.2],pch=4)
plot.axis.1<-1#
plot.axis.2<-2#
plot(pco[,plot.axis.1],pco[,plot.axis.2],type="n")#
for(i in 1:length(lungfish.tree$edge.length)) {#
#
	from.row<-match(as.character(lungfish.tree$edge[i,1]),rownames(lungfish.Gower))#
	# If this is a terminal branch:#
	if(lungfish.tree$edge[i,2] <= Ntip(lungfish.tree)) {#
		to.row<-match(lungfish.tree$tip.label[lungfish.tree$edge[i,2]],rownames(lungfish.Gower))#
	} else {#
		to.row<-match(as.character(lungfish.tree$edge[i,2]),rownames(lungfish.Gower))#
	}#
	x<-c(pco[from.row,plot.axis.1],pco[to.row,plot.axis.1])#
	y<-c(pco[from.row,plot.axis.2],pco[to.row,plot.axis.2])#
#
	lines(x,y,col="grey")#
}#
points(pco[1:Ntip(lungfish.tree),plot.axis.1],pco[1:Ntip(lungfish.tree),plot.axis.2],pch=4)
lungfish.Gower
as.dist(lungfish.Gower)
as.vector(as.dist(lungfish.Gower))
plot(as.vector(as.dist(lungfish.Gower)))
plot(sort(as.vector(as.dist(lungfish.Gower))))
names(lungfish.distances)
Get in the necessary functions:#
source("http://www.graemetlloyd.com/pubdata/functions_3.r")#
#
# Library:#
library(phytools)#
library(paleotree)#
#
# Read in a data matrix from my web site (pick a different one from this!):#
lungfish.matrix<-get.nexus("http://www.graemetlloyd.com/nexus/Lloyd_etal_2012a.nex")#
#
# Read in tree:#
lungfish.tree<-read.tree("http://www.graemetlloyd.com/firstmpt/Lloyd_etal_2012a.tre")#
#
# Read in ages:#
lungfish.ages<-read.table("~/Documents/Teaching/External/PaleoDB Summer Course 2013/daterr.txt",row.names=1)#
#
# Time-scale tree using equal method:#
lungfish.tree<-timePaleoPhy(lungfish.tree,lungfish.ages,type="equal",vartime=5)#
#
# Estimate ancestral state values:#
lungfish.ancestors<-anc.state.est.matrix(lungfish.matrix,lungfish.tree)#
#
# Rename ancestor rownames by descendant taxa that define them:#
for(j in 1:length(lungfish.ancestors[,1])) rownames(lungfish.ancestors)[j]<-paste(sort(lungfish.tree$tip.label[find.descendants(rownames(lungfish.ancestors)[j],lungfish.tree)]),collapse="%%")#
#
# Add ancestors into matrix:#
lungfish.matrix$matrix<-rbind(lungfish.matrix$matrix,lungfish.ancestors)#
#
# Get distance matrices:#
lungfish.distances<-dist.clad.matrix(lungfish.matrix)#
#
# Get Gower dissimilarity matrix:#
lungfish.Gower<-lungfish.distances$dist.matrix/lungfish.distances$comp.char.matrix#
lungfish.Gower<-lungfish.distances$dist.matrix/lungfish.distances$max.dist.matrix#
# Trim taxa that cause missing data:#
trim.out<-trim.clad.dist.matrix(lungfish.Gower,lungfish.tree)#
#
# Only run the next two lines if you do not get the "There are no taxa to remove" warning:#
#
# Give complete distance matrix:#
lungfish.Gower<-trim.out$dist.matrix#
#
# Get corresponding tree:#
lungfish.tree<-trim.out$tree#
#
# Carry on after here if you did get the "There are no taxa to remove" warning:#
#
# Find node names:#
node.names<-rownames(lungfish.Gower)[grep("%%",rownames(lungfish.Gower))]#
for(j in 1:length(node.names)) names(node.names)[j]<-find.ancestor(strsplit(node.names[j],"%%")[[1]],lungfish.tree)#
rownames(lungfish.Gower)[match(node.names,rownames(lungfish.Gower))]<-names(node.names)#
colnames(lungfish.Gower)[match(node.names,colnames(lungfish.Gower))]<-names(node.names)#
#
# Perform principal coordinates on the data:#
pco<-cmdscale(lungfish.Gower,k=length(lungfish.Gower[,1])-1)#
#
# Get variance of pco axes:#
pco.variances<-apply(pco,2,var)/sum(apply(pco,2,var))*100#
plot.axis.1<-1#
plot.axis.2<-2#
plot(pco[,plot.axis.1],pco[,plot.axis.2],type="n")#
for(i in 1:length(lungfish.tree$edge.length)) {#
#
	from.row<-match(as.character(lungfish.tree$edge[i,1]),rownames(lungfish.Gower))#
	# If this is a terminal branch:#
	if(lungfish.tree$edge[i,2] <= Ntip(lungfish.tree)) {#
		to.row<-match(lungfish.tree$tip.label[lungfish.tree$edge[i,2]],rownames(lungfish.Gower))#
	} else {#
		to.row<-match(as.character(lungfish.tree$edge[i,2]),rownames(lungfish.Gower))#
	}#
	x<-c(pco[from.row,plot.axis.1],pco[to.row,plot.axis.1])#
	y<-c(pco[from.row,plot.axis.2],pco[to.row,plot.axis.2])#
#
	lines(x,y,col="grey")#
}#
points(pco[1:Ntip(lungfish.tree),plot.axis.1],pco[1:Ntip(lungfish.tree),plot.axis.2],pch=4)
lungfish.Gower
diag(lungfish.Gower)
diag(lungfish.Gower)<-0
diag(lungfish.Gower)
lungfish.Gower<-lungfish.distances$dist.matrix/lungfish.distances$max.dist.matrix#
diag(lungfish.Gower)<-0#
# Trim taxa that cause missing data:#
trim.out<-trim.clad.dist.matrix(lungfish.Gower,lungfish.tree)#
#
# Only run the next two lines if you do not get the "There are no taxa to remove" warning:#
#
# Give complete distance matrix:#
lungfish.Gower<-trim.out$dist.matrix#
#
# Get corresponding tree:#
lungfish.tree<-trim.out$tree#
#
# Carry on after here if you did get the "There are no taxa to remove" warning:#
#
# Find node names:#
node.names<-rownames(lungfish.Gower)[grep("%%",rownames(lungfish.Gower))]#
for(j in 1:length(node.names)) names(node.names)[j]<-find.ancestor(strsplit(node.names[j],"%%")[[1]],lungfish.tree)#
rownames(lungfish.Gower)[match(node.names,rownames(lungfish.Gower))]<-names(node.names)#
colnames(lungfish.Gower)[match(node.names,colnames(lungfish.Gower))]<-names(node.names)#
#
# Perform principal coordinates on the data:#
pco<-cmdscale(lungfish.Gower,k=length(lungfish.Gower[,1])-1)#
#
# Get variance of pco axes:#
pco.variances<-apply(pco,2,var)/sum(apply(pco,2,var))*100#
plot.axis.1<-1#
plot.axis.2<-2#
plot(pco[,plot.axis.1],pco[,plot.axis.2],type="n")#
for(i in 1:length(lungfish.tree$edge.length)) {#
#
	from.row<-match(as.character(lungfish.tree$edge[i,1]),rownames(lungfish.Gower))#
	# If this is a terminal branch:#
	if(lungfish.tree$edge[i,2] <= Ntip(lungfish.tree)) {#
		to.row<-match(lungfish.tree$tip.label[lungfish.tree$edge[i,2]],rownames(lungfish.Gower))#
	} else {#
		to.row<-match(as.character(lungfish.tree$edge[i,2]),rownames(lungfish.Gower))#
	}#
	x<-c(pco[from.row,plot.axis.1],pco[to.row,plot.axis.1])#
	y<-c(pco[from.row,plot.axis.2],pco[to.row,plot.axis.2])#
#
	lines(x,y,col="grey")#
}#
points(pco[1:Ntip(lungfish.tree),plot.axis.1],pco[1:Ntip(lungfish.tree),plot.axis.2],pch=4)
lungfish.Gower
as.dist(lungfish.Gower)
plot(sort(as.dist(lungfish.Gower)))
Get in the necessary functions:#
source("http://www.graemetlloyd.com/pubdata/functions_3.r")#
#
# Library:#
library(phytools)#
library(paleotree)#
#
# Read in a data matrix from my web site (pick a different one from this!):#
lungfish.matrix<-get.nexus("http://www.graemetlloyd.com/nexus/Lloyd_etal_2012a.nex")#
#
# Read in tree:#
lungfish.tree<-read.tree("http://www.graemetlloyd.com/firstmpt/Lloyd_etal_2012a.tre")#
#
# Read in ages:#
lungfish.ages<-read.table("~/Documents/Teaching/External/PaleoDB Summer Course 2013/daterr.txt",row.names=1)#
#
# Time-scale tree using equal method:#
lungfish.tree<-timePaleoPhy(lungfish.tree,lungfish.ages,type="equal",vartime=5)#
#
# Estimate ancestral state values:#
lungfish.ancestors<-anc.state.est.matrix(lungfish.matrix,lungfish.tree)#
#
# Rename ancestor rownames by descendant taxa that define them:#
for(j in 1:length(lungfish.ancestors[,1])) rownames(lungfish.ancestors)[j]<-paste(sort(lungfish.tree$tip.label[find.descendants(rownames(lungfish.ancestors)[j],lungfish.tree)]),collapse="%%")#
#
# Add ancestors into matrix:#
lungfish.matrix$matrix<-rbind(lungfish.matrix$matrix,lungfish.ancestors)#
#
# Get distance matrices:#
lungfish.distances<-dist.clad.matrix(lungfish.matrix)#
#
# Get Gower dissimilarity matrix:#
lungfish.Gower<-lungfish.distances$dist.matrix/lungfish.distances$comp.char.matrix#
#
# Get maximum distance matrix instead:#
#lungfish.Gower<-lungfish.distances$dist.matrix/lungfish.distances$max.dist.matrix#
#diag(lungfish.Gower)<-0#
#
# Trim taxa that cause missing data:#
trim.out<-trim.clad.dist.matrix(lungfish.Gower,lungfish.tree)#
#
# Only run the next two lines if you do not get the "There are no taxa to remove" warning:#
#
# Give complete distance matrix:#
lungfish.Gower<-trim.out$dist.matrix#
#
# Get corresponding tree:#
lungfish.tree<-trim.out$tree#
#
# Carry on after here if you did get the "There are no taxa to remove" warning:#
#
# Find node names:#
node.names<-rownames(lungfish.Gower)[grep("%%",rownames(lungfish.Gower))]#
for(j in 1:length(node.names)) names(node.names)[j]<-find.ancestor(strsplit(node.names[j],"%%")[[1]],lungfish.tree)#
rownames(lungfish.Gower)[match(node.names,rownames(lungfish.Gower))]<-names(node.names)#
colnames(lungfish.Gower)[match(node.names,colnames(lungfish.Gower))]<-names(node.names)#
#
# Perform principal coordinates on the data:#
pco<-cmdscale(lungfish.Gower,k=length(lungfish.Gower[,1])-1)#
#
# Get variance of pco axes:#
pco.variances<-apply(pco,2,var)/sum(apply(pco,2,var))*100#
plot.axis.1<-1#
plot.axis.2<-2#
plot(pco[,plot.axis.1],pco[,plot.axis.2],type="n")#
for(i in 1:length(lungfish.tree$edge.length)) {#
#
	from.row<-match(as.character(lungfish.tree$edge[i,1]),rownames(lungfish.Gower))#
	# If this is a terminal branch:#
	if(lungfish.tree$edge[i,2] <= Ntip(lungfish.tree)) {#
		to.row<-match(lungfish.tree$tip.label[lungfish.tree$edge[i,2]],rownames(lungfish.Gower))#
	} else {#
		to.row<-match(as.character(lungfish.tree$edge[i,2]),rownames(lungfish.Gower))#
	}#
	x<-c(pco[from.row,plot.axis.1],pco[to.row,plot.axis.1])#
	y<-c(pco[from.row,plot.axis.2],pco[to.row,plot.axis.2])#
#
	lines(x,y,col="grey")#
}#
points(pco[1:Ntip(lungfish.tree),plot.axis.1],pco[1:Ntip(lungfish.tree),plot.axis.2],pch=4)
Get in the necessary functions:#
source("http://www.graemetlloyd.com/pubdata/functions_3.r")#
#
# Library:#
library(phytools)#
library(paleotree)#
#
# Read in a data matrix from my web site (pick a different one from this!):#
lungfish.matrix<-get.nexus("http://www.graemetlloyd.com/nexus/Lloyd_etal_2012a.nex")#
#
# Read in tree:#
lungfish.tree<-read.tree("http://www.graemetlloyd.com/firstmpt/Lloyd_etal_2012a.tre")#
#
# Read in ages:#
lungfish.ages<-read.table("~/Documents/Teaching/External/PaleoDB Summer Course 2013/daterr.txt",row.names=1)#
#
# Time-scale tree using equal method:#
lungfish.tree<-timePaleoPhy(lungfish.tree,lungfish.ages,type="equal",vartime=5)#
#
# Estimate ancestral state values:#
lungfish.ancestors<-anc.state.est.matrix(lungfish.matrix,lungfish.tree)#
#
# Rename ancestor rownames by descendant taxa that define them:#
for(j in 1:length(lungfish.ancestors[,1])) rownames(lungfish.ancestors)[j]<-paste(sort(lungfish.tree$tip.label[find.descendants(rownames(lungfish.ancestors)[j],lungfish.tree)]),collapse="%%")#
#
# Add ancestors into matrix:#
lungfish.matrix$matrix<-rbind(lungfish.matrix$matrix,lungfish.ancestors)#
#
# Get distance matrices:#
lungfish.distances<-dist.clad.matrix(lungfish.matrix)#
#
# Get Gower dissimilarity matrix:#
lungfish.Gower<-lungfish.distances$dist.matrix/lungfish.distances$comp.char.matrix#
#
# Get maximum distance matrix instead:#
lungfish.Gower<-lungfish.distances$dist.matrix/lungfish.distances$max.dist.matrix#
diag(lungfish.Gower)<-0#
#
# Trim taxa that cause missing data:#
trim.out<-trim.clad.dist.matrix(lungfish.Gower,lungfish.tree)#
#
# Only run the next two lines if you do not get the "There are no taxa to remove" warning:#
#
# Give complete distance matrix:#
lungfish.Gower<-trim.out$dist.matrix#
#
# Get corresponding tree:#
lungfish.tree<-trim.out$tree#
#
# Carry on after here if you did get the "There are no taxa to remove" warning:#
#
# Find node names:#
node.names<-rownames(lungfish.Gower)[grep("%%",rownames(lungfish.Gower))]#
for(j in 1:length(node.names)) names(node.names)[j]<-find.ancestor(strsplit(node.names[j],"%%")[[1]],lungfish.tree)#
rownames(lungfish.Gower)[match(node.names,rownames(lungfish.Gower))]<-names(node.names)#
colnames(lungfish.Gower)[match(node.names,colnames(lungfish.Gower))]<-names(node.names)#
#
# Perform principal coordinates on the data:#
pco<-cmdscale(lungfish.Gower,k=length(lungfish.Gower[,1])-1)#
#
# Get variance of pco axes:#
pco.variances<-apply(pco,2,var)/sum(apply(pco,2,var))*100#
#
# Set PCO axes you want to plot (worth doing this as makes it easier later to plot different ones):#
plot.axis.1<-1#
plot.axis.2<-2
First plot an empty ordination space:#
plot(pco[,plot.axis.1],pco[,plot.axis.2],type="n")#
#
# For each branch in the tree:#
for(i in 1:length(lungfish.tree$edge.length)) {#
#
	# Find from value for branch:#
	from.row<-match(as.character(lungfish.tree$edge[i,1]),rownames(lungfish.Gower))#
	# If this is a terminal branch:#
	if(lungfish.tree$edge[i,2] <= Ntip(lungfish.tree)) {#
		# Find the tip label as text in the PCO matrix rownames:#
		to.row<-match(lungfish.tree$tip.label[lungfish.tree$edge[i,2]],rownames(lungfish.Gower))#
	# If this is an internal branch:#
	} else {#
		# Find the node label as a number in the PCO matrix rownames:#
		to.row<-match(as.character(lungfish.tree$edge[i,2]),rownames(lungfish.Gower))#
	}#
#
	# Set x and y values for line:#
	x<-c(pco[from.row,plot.axis.1],pco[to.row,plot.axis.1])#
	y<-c(pco[from.row,plot.axis.2],pco[to.row,plot.axis.2])#
#
	# Plot branch:#
	lines(x,y,col="grey")#
}#
#
# Plot tips only into ordination space as black Xs:#
points(pco[1:Ntip(lungfish.tree),plot.axis.1],pco[1:Ntip(lungfish.tree),plot.axis.2],pch=4)
Set PCO axes you want to plot (worth doing this as makes it easier later to plot different ones):#
plot.axis.1<-1#
plot.axis.2<-2#
#
# First plot an empty ordination space:#
plot(pco[,plot.axis.1],pco[,plot.axis.2],type="n")#
#
# For each branch in the tree:#
for(i in 1:length(lungfish.tree$edge.length)) {#
#
	# Find from value for branch:#
	from.row<-match(as.character(lungfish.tree$edge[i,1]),rownames(lungfish.Gower))#
	# If this is a terminal branch:#
	if(lungfish.tree$edge[i,2] <= Ntip(lungfish.tree)) {#
		# Find the tip label as text in the PCO matrix rownames:#
		to.row<-match(lungfish.tree$tip.label[lungfish.tree$edge[i,2]],rownames(lungfish.Gower))#
	# If this is an internal branch:#
	} else {#
		# Find the node label as a number in the PCO matrix rownames:#
		to.row<-match(as.character(lungfish.tree$edge[i,2]),rownames(lungfish.Gower))#
	}#
#
	# Set x and y values for line:#
	x<-c(pco[from.row,plot.axis.1],pco[to.row,plot.axis.1])#
	y<-c(pco[from.row,plot.axis.2],pco[to.row,plot.axis.2])#
#
	# Plot branch:#
	lines(x,y,col="grey")#
}#
#
# Plot tips only into ordination space as black Xs:#
points(pco[1:Ntip(lungfish.tree),plot.axis.1],pco[1:Ntip(lungfish.tree),plot.axis.2],pch=4)#
#
text(pco[,plot.axis.1],pco[,plot.axis.2],lungfish.tree$tip.label,cex=0.5)
Set PCO axes you want to plot (worth doing this as makes it easier later to plot different ones):#
plot.axis.1<-1#
plot.axis.2<-2#
#
# First plot an empty ordination space:#
plot(pco[,plot.axis.1],pco[,plot.axis.2],type="n")#
#
# For each branch in the tree:#
for(i in 1:length(lungfish.tree$edge.length)) {#
#
	# Find from value for branch:#
	from.row<-match(as.character(lungfish.tree$edge[i,1]),rownames(lungfish.Gower))#
	# If this is a terminal branch:#
	if(lungfish.tree$edge[i,2] <= Ntip(lungfish.tree)) {#
		# Find the tip label as text in the PCO matrix rownames:#
		to.row<-match(lungfish.tree$tip.label[lungfish.tree$edge[i,2]],rownames(lungfish.Gower))#
	# If this is an internal branch:#
	} else {#
		# Find the node label as a number in the PCO matrix rownames:#
		to.row<-match(as.character(lungfish.tree$edge[i,2]),rownames(lungfish.Gower))#
	}#
#
	# Set x and y values for line:#
	x<-c(pco[from.row,plot.axis.1],pco[to.row,plot.axis.1])#
	y<-c(pco[from.row,plot.axis.2],pco[to.row,plot.axis.2])#
#
	# Plot branch:#
	lines(x,y,col="grey")#
}#
#
# Plot tips only into ordination space as black Xs:#
points(pco[1:Ntip(lungfish.tree),plot.axis.1],pco[1:Ntip(lungfish.tree),plot.axis.2],pch=4)#
#
text(pco[1:Ntip(lungfish.tree),plot.axis.1],pco[1:Ntip(lungfish.tree),plot.axis.2],rownames(pco)[1:Ntip(lungfish.tree)],cex=0.5)
paste(plot.axis.1)
paste("PCO",plot.axis.1)
paste("PC",plot.axis.1,sep="")
Set PCO axes you want to plot (worth doing this as makes it easier later to plot different ones):#
plot.axis.1<-1#
plot.axis.2<-2#
#
# First plot an empty ordination space:#
plot(pco[,plot.axis.1],pco[,plot.axis.2],type="n",xlab=paste("PC",plot.axis.1,sep=""),ylab=paste("PC",plot.axis.2,sep=""))#
#
# For each branch in the tree:#
for(i in 1:length(lungfish.tree$edge.length)) {#
#
	# Find from value for branch:#
	from.row<-match(as.character(lungfish.tree$edge[i,1]),rownames(lungfish.Gower))#
	# If this is a terminal branch:#
	if(lungfish.tree$edge[i,2] <= Ntip(lungfish.tree)) {#
		# Find the tip label as text in the PCO matrix rownames:#
		to.row<-match(lungfish.tree$tip.label[lungfish.tree$edge[i,2]],rownames(lungfish.Gower))#
	# If this is an internal branch:#
	} else {#
		# Find the node label as a number in the PCO matrix rownames:#
		to.row<-match(as.character(lungfish.tree$edge[i,2]),rownames(lungfish.Gower))#
	}#
#
	# Set x and y values for line:#
	x<-c(pco[from.row,plot.axis.1],pco[to.row,plot.axis.1])#
	y<-c(pco[from.row,plot.axis.2],pco[to.row,plot.axis.2])#
#
	# Plot branch:#
	lines(x,y,col="grey")#
}#
#
# Plot tips only into ordination space as black Xs:#
points(pco[1:Ntip(lungfish.tree),plot.axis.1],pco[1:Ntip(lungfish.tree),plot.axis.2],pch=4)
Set PCO axes you want to plot (worth doing this as makes it easier later to plot different ones):#
plot.axis.1<-1#
plot.axis.2<-2#
#
# First plot an empty ordination space:#
plot(pco[,plot.axis.1],pco[,plot.axis.2],type="n",xlab=paste("PC",plot.axis.1,sep=""),ylab=paste("PC",plot.axis.2,sep=""))#
#
# For each branch in the tree:#
for(i in 1:length(lungfish.tree$edge.length)) {#
#
	# Find from value for branch:#
	from.row<-match(as.character(lungfish.tree$edge[i,1]),rownames(lungfish.Gower))#
	# If this is a terminal branch:#
	if(lungfish.tree$edge[i,2] <= Ntip(lungfish.tree)) {#
		# Find the tip label as text in the PCO matrix rownames:#
		to.row<-match(lungfish.tree$tip.label[lungfish.tree$edge[i,2]],rownames(lungfish.Gower))#
	# If this is an internal branch:#
	} else {#
		# Find the node label as a number in the PCO matrix rownames:#
		to.row<-match(as.character(lungfish.tree$edge[i,2]),rownames(lungfish.Gower))#
	}#
#
	# Set x and y values for line:#
	x<-c(pco[from.row,plot.axis.1],pco[to.row,plot.axis.1])#
	y<-c(pco[from.row,plot.axis.2],pco[to.row,plot.axis.2])#
#
	# Plot branch:#
	lines(x,y,col="grey")#
}#
#
# Plot tips only into ordination space as black Xs:#
points(pco[1:Ntip(lungfish.tree),plot.axis.1],pco[1:Ntip(lungfish.tree),plot.axis.2],pch=4)#
#
# Add taxon names as text:#
text(pco[1:Ntip(lungfish.tree),plot.axis.1],pco[1:Ntip(lungfish.tree),plot.axis.2],rownames(pco)[1:Ntip(lungfish.tree)],cex=0.5)
Ntip(lungfish.tree)
Ntip(lungfish.tree)+1
match(as.character(Ntip(lungfish.tree)+1),rownames(pco))
Set PCO axes you want to plot (worth doing this as makes it easier later to plot different ones):#
plot.axis.1<-1#
plot.axis.2<-2#
#
# First plot an empty ordination space:#
plot(pco[,plot.axis.1],pco[,plot.axis.2],type="n",xlab=paste("PC",plot.axis.1,sep=""),ylab=paste("PC",plot.axis.2,sep=""))#
#
# For each branch in the tree:#
for(i in 1:length(lungfish.tree$edge.length)) {#
#
	# Find from value for branch:#
	from.row<-match(as.character(lungfish.tree$edge[i,1]),rownames(lungfish.Gower))#
	# If this is a terminal branch:#
	if(lungfish.tree$edge[i,2] <= Ntip(lungfish.tree)) {#
		# Find the tip label as text in the PCO matrix rownames:#
		to.row<-match(lungfish.tree$tip.label[lungfish.tree$edge[i,2]],rownames(lungfish.Gower))#
	# If this is an internal branch:#
	} else {#
		# Find the node label as a number in the PCO matrix rownames:#
		to.row<-match(as.character(lungfish.tree$edge[i,2]),rownames(lungfish.Gower))#
	}#
#
	# Set x and y values for line:#
	x<-c(pco[from.row,plot.axis.1],pco[to.row,plot.axis.1])#
	y<-c(pco[from.row,plot.axis.2],pco[to.row,plot.axis.2])#
#
	# Plot branch:#
	lines(x,y,col="grey")#
}#
#
# Plot root node:#
points(pco[match(as.character(Ntip(lungfish.tree)+1),rownames(pco)),plot.axis.1],pco[match(as.character(Ntip(lungfish.tree)+1),rownames(pco)),plot.axis.2],col="red")#
#
# Plot tips only into ordination space as black Xs:#
points(pco[1:Ntip(lungfish.tree),plot.axis.1],pco[1:Ntip(lungfish.tree),plot.axis.2],pch=4)#
#
# Add taxon names as text:#
text(pco[1:Ntip(lungfish.tree),plot.axis.1],pco[1:Ntip(lungfish.tree),plot.axis.2],rownames(pco)[1:Ntip(lungfish.tree)],cex=0.5)
Set PCO axes you want to plot (worth doing this as makes it easier later to plot different ones):#
plot.axis.1<-1#
plot.axis.2<-2#
#
# First plot an empty ordination space:#
plot(pco[,plot.axis.1],pco[,plot.axis.2],type="n",xlab=paste("PC",plot.axis.1,sep=""),ylab=paste("PC",plot.axis.2,sep=""))#
#
# For each branch in the tree:#
for(i in 1:length(lungfish.tree$edge.length)) {#
#
	# Find from value for branch:#
	from.row<-match(as.character(lungfish.tree$edge[i,1]),rownames(lungfish.Gower))#
	# If this is a terminal branch:#
	if(lungfish.tree$edge[i,2] <= Ntip(lungfish.tree)) {#
		# Find the tip label as text in the PCO matrix rownames:#
		to.row<-match(lungfish.tree$tip.label[lungfish.tree$edge[i,2]],rownames(lungfish.Gower))#
	# If this is an internal branch:#
	} else {#
		# Find the node label as a number in the PCO matrix rownames:#
		to.row<-match(as.character(lungfish.tree$edge[i,2]),rownames(lungfish.Gower))#
	}#
#
	# Set x and y values for line:#
	x<-c(pco[from.row,plot.axis.1],pco[to.row,plot.axis.1])#
	y<-c(pco[from.row,plot.axis.2],pco[to.row,plot.axis.2])#
#
	# Plot branch:#
	lines(x,y,col="grey")#
}#
#
# Plot root node:#
points(pco[match(as.character(Ntip(lungfish.tree)+1),rownames(pco)),plot.axis.1],pco[match(as.character(Ntip(lungfish.tree)+1),rownames(pco)),plot.axis.2],col="red")#
#
# Plot tips only into ordination space as black Xs:#
points(pco[1:Ntip(lungfish.tree),plot.axis.1],pco[1:Ntip(lungfish.tree),plot.axis.2],pch=4)
Set PCO axes you want to plot (worth doing this as makes it easier later to plot different ones):#
plot.axis.1<-1#
plot.axis.2<-2#
#
# First plot an empty ordination space:#
plot(pco[,plot.axis.1],pco[,plot.axis.2],type="n",xlab=paste("PC",plot.axis.1,sep=""),ylab=paste("PC",plot.axis.2,sep=""),main="Tree branches (lines) with tips (Xs) and root (O)")#
#
# For each branch in the tree:#
for(i in 1:length(lungfish.tree$edge.length)) {#
#
	# Find from value for branch:#
	from.row<-match(as.character(lungfish.tree$edge[i,1]),rownames(lungfish.Gower))#
	# If this is a terminal branch:#
	if(lungfish.tree$edge[i,2] <= Ntip(lungfish.tree)) {#
		# Find the tip label as text in the PCO matrix rownames:#
		to.row<-match(lungfish.tree$tip.label[lungfish.tree$edge[i,2]],rownames(lungfish.Gower))#
	# If this is an internal branch:#
	} else {#
		# Find the node label as a number in the PCO matrix rownames:#
		to.row<-match(as.character(lungfish.tree$edge[i,2]),rownames(lungfish.Gower))#
	}#
#
	# Set x and y values for line:#
	x<-c(pco[from.row,plot.axis.1],pco[to.row,plot.axis.1])#
	y<-c(pco[from.row,plot.axis.2],pco[to.row,plot.axis.2])#
#
	# Plot branch:#
	lines(x,y,col="grey")#
}#
#
# Plot root node:#
points(pco[match(as.character(Ntip(lungfish.tree)+1),rownames(pco)),plot.axis.1],pco[match(as.character(Ntip(lungfish.tree)+1),rownames(pco)),plot.axis.2],col="red")#
#
# Plot tips only into ordination space as black Xs:#
points(pco[1:Ntip(lungfish.tree),plot.axis.1],pco[1:Ntip(lungfish.tree),plot.axis.2],pch=4)
Set PCO axes you want to plot (worth doing this as makes it easier later to plot different ones):#
plot.axis.1<-2#
plot.axis.2<-3#
#
# First plot an empty ordination space:#
plot(pco[,plot.axis.1],pco[,plot.axis.2],type="n",xlab=paste("PC",plot.axis.1,sep=""),ylab=paste("PC",plot.axis.2,sep=""),main="Tree branches (lines) with tips (Xs) and root (O)")#
#
# For each branch in the tree:#
for(i in 1:length(lungfish.tree$edge.length)) {#
#
	# Find from value for branch:#
	from.row<-match(as.character(lungfish.tree$edge[i,1]),rownames(lungfish.Gower))#
	# If this is a terminal branch:#
	if(lungfish.tree$edge[i,2] <= Ntip(lungfish.tree)) {#
		# Find the tip label as text in the PCO matrix rownames:#
		to.row<-match(lungfish.tree$tip.label[lungfish.tree$edge[i,2]],rownames(lungfish.Gower))#
	# If this is an internal branch:#
	} else {#
		# Find the node label as a number in the PCO matrix rownames:#
		to.row<-match(as.character(lungfish.tree$edge[i,2]),rownames(lungfish.Gower))#
	}#
#
	# Set x and y values for line:#
	x<-c(pco[from.row,plot.axis.1],pco[to.row,plot.axis.1])#
	y<-c(pco[from.row,plot.axis.2],pco[to.row,plot.axis.2])#
#
	# Plot branch:#
	lines(x,y,col="grey")#
}#
#
# Plot root node:#
points(pco[match(as.character(Ntip(lungfish.tree)+1),rownames(pco)),plot.axis.1],pco[match(as.character(Ntip(lungfish.tree)+1),rownames(pco)),plot.axis.2],col="red")#
#
# Plot tips only into ordination space as black Xs:#
points(pco[1:Ntip(lungfish.tree),plot.axis.1],pco[1:Ntip(lungfish.tree),plot.axis.2],pch=4)
Set PCO axes you want to plot (worth doing this as makes it easier later to plot different ones):#
plot.axis.1<-1#
plot.axis.2<-3#
#
# First plot an empty ordination space:#
plot(pco[,plot.axis.1],pco[,plot.axis.2],type="n",xlab=paste("PC",plot.axis.1,sep=""),ylab=paste("PC",plot.axis.2,sep=""),main="Tree branches (lines) with tips (Xs) and root (O)")#
#
# For each branch in the tree:#
for(i in 1:length(lungfish.tree$edge.length)) {#
#
	# Find from value for branch:#
	from.row<-match(as.character(lungfish.tree$edge[i,1]),rownames(lungfish.Gower))#
	# If this is a terminal branch:#
	if(lungfish.tree$edge[i,2] <= Ntip(lungfish.tree)) {#
		# Find the tip label as text in the PCO matrix rownames:#
		to.row<-match(lungfish.tree$tip.label[lungfish.tree$edge[i,2]],rownames(lungfish.Gower))#
	# If this is an internal branch:#
	} else {#
		# Find the node label as a number in the PCO matrix rownames:#
		to.row<-match(as.character(lungfish.tree$edge[i,2]),rownames(lungfish.Gower))#
	}#
#
	# Set x and y values for line:#
	x<-c(pco[from.row,plot.axis.1],pco[to.row,plot.axis.1])#
	y<-c(pco[from.row,plot.axis.2],pco[to.row,plot.axis.2])#
#
	# Plot branch:#
	lines(x,y,col="grey")#
}#
#
# Plot root node:#
points(pco[match(as.character(Ntip(lungfish.tree)+1),rownames(pco)),plot.axis.1],pco[match(as.character(Ntip(lungfish.tree)+1),rownames(pco)),plot.axis.2],col="red")#
#
# Plot tips only into ordination space as black Xs:#
points(pco[1:Ntip(lungfish.tree),plot.axis.1],pco[1:Ntip(lungfish.tree),plot.axis.2],pch=4)
Set PCO axes you want to plot (worth doing this as makes it easier later to plot different ones):#
plot.axis.1<-1#
plot.axis.2<-3#
#
# First plot an empty ordination space:#
plot(pco[,plot.axis.1],pco[,plot.axis.2],type="n",xlab=paste("PC",plot.axis.1,sep=""),ylab=paste("PC",plot.axis.2,sep=""),main="Tree branches (lines) with tips (Xs) and root (O)")#
#
# For each branch in the tree:#
for(i in 1:length(lungfish.tree$edge.length)) {#
#
	# Find from value for branch:#
	from.row<-match(as.character(lungfish.tree$edge[i,1]),rownames(lungfish.Gower))#
	# If this is a terminal branch:#
	if(lungfish.tree$edge[i,2] <= Ntip(lungfish.tree)) {#
		# Find the tip label as text in the PCO matrix rownames:#
		to.row<-match(lungfish.tree$tip.label[lungfish.tree$edge[i,2]],rownames(lungfish.Gower))#
	# If this is an internal branch:#
	} else {#
		# Find the node label as a number in the PCO matrix rownames:#
		to.row<-match(as.character(lungfish.tree$edge[i,2]),rownames(lungfish.Gower))#
	}#
#
	# Set x and y values for line:#
	x<-c(pco[from.row,plot.axis.1],pco[to.row,plot.axis.1])#
	y<-c(pco[from.row,plot.axis.2],pco[to.row,plot.axis.2])#
#
	# Plot branch:#
	lines(x,y,col="grey")#
}#
#
# Plot root node:#
points(pco[match(as.character(Ntip(lungfish.tree)+1),rownames(pco)),plot.axis.1],pco[match(as.character(Ntip(lungfish.tree)+1),rownames(pco)),plot.axis.2],col="red")#
#
# Plot tips only into ordination space as black Xs:#
points(pco[1:Ntip(lungfish.tree),plot.axis.1],pco[1:Ntip(lungfish.tree),plot.axis.2],pch=4)#
#
# Add taxon names as text:#
text(pco[1:Ntip(lungfish.tree),plot.axis.1],pco[1:Ntip(lungfish.tree),plot.axis.2],rownames(pco)[1:Ntip(lungfish.tree)],cex=0.5)
Set PCO axes you want to plot (worth doing this as makes it easier later to plot different ones):#
plot.axis.1<-1#
plot.axis.2<-3#
#
# First plot an empty ordination space:#
plot(pco[,plot.axis.1],pco[,plot.axis.2],type="n",xlab=paste("PC",plot.axis.1,sep=""),ylab=paste("PC",plot.axis.2,sep=""),main="Tree branches (lines) with tips (Xs) and root (O)")#
#
# For each branch in the tree:#
for(i in 1:length(lungfish.tree$edge.length)) {#
#
	# Find from value for branch:#
	from.row<-match(as.character(lungfish.tree$edge[i,1]),rownames(lungfish.Gower))#
	# If this is a terminal branch:#
	if(lungfish.tree$edge[i,2] <= Ntip(lungfish.tree)) {#
		# Find the tip label as text in the PCO matrix rownames:#
		to.row<-match(lungfish.tree$tip.label[lungfish.tree$edge[i,2]],rownames(lungfish.Gower))#
	# If this is an internal branch:#
	} else {#
		# Find the node label as a number in the PCO matrix rownames:#
		to.row<-match(as.character(lungfish.tree$edge[i,2]),rownames(lungfish.Gower))#
	}#
#
	# Set x and y values for line:#
	x<-c(pco[from.row,plot.axis.1],pco[to.row,plot.axis.1])#
	y<-c(pco[from.row,plot.axis.2],pco[to.row,plot.axis.2])#
#
	# Plot branch:#
	lines(x,y,col="grey")#
}#
#
# Plot root node:#
points(pco[match(as.character(Ntip(lungfish.tree)+1),rownames(pco)),plot.axis.1],pco[match(as.character(Ntip(lungfish.tree)+1),rownames(pco)),plot.axis.2],col="red")#
#
# Plot tips only into ordination space as black Xs:#
points(pco[1:Ntip(lungfish.tree),plot.axis.1],pco[1:Ntip(lungfish.tree),plot.axis.2],pch=4)
Set PCO axes you want to plot (worth doing this as makes it easier later to plot different ones):#
plot.axis.1<-1#
plot.axis.2<-3#
#
# First plot an empty ordination space:#
plot(pco[,plot.axis.1],pco[,plot.axis.2],type="n",xlab=paste("PC",plot.axis.1,sep=""),ylab=paste("PC",plot.axis.2,sep=""),main="Tree branches (lines) with tips (Xs) and root (O)")#
#
# For each branch in the tree:#
for(i in 1:length(lungfish.tree$edge.length)) {#
#
	# Find from value for branch:#
	from.row<-match(as.character(lungfish.tree$edge[i,1]),rownames(lungfish.Gower))#
	# If this is a terminal branch:#
	if(lungfish.tree$edge[i,2] <= Ntip(lungfish.tree)) {#
		# Find the tip label as text in the PCO matrix rownames:#
		to.row<-match(lungfish.tree$tip.label[lungfish.tree$edge[i,2]],rownames(lungfish.Gower))#
	# If this is an internal branch:#
	} else {#
		# Find the node label as a number in the PCO matrix rownames:#
		to.row<-match(as.character(lungfish.tree$edge[i,2]),rownames(lungfish.Gower))#
	}#
#
	# Set x and y values for line:#
	x<-c(pco[from.row,plot.axis.1],pco[to.row,plot.axis.1])#
	y<-c(pco[from.row,plot.axis.2],pco[to.row,plot.axis.2])#
#
	# Plot branch:#
	lines(x,y,col="grey",lwd=2)#
}#
#
# Plot root node:#
points(pco[match(as.character(Ntip(lungfish.tree)+1),rownames(pco)),plot.axis.1],pco[match(as.character(Ntip(lungfish.tree)+1),rownames(pco)),plot.axis.2],col="red",cex=2)#
#
# Plot tips only into ordination space as black Xs:#
points(pco[1:Ntip(lungfish.tree),plot.axis.1],pco[1:Ntip(lungfish.tree),plot.axis.2],pch=4,cex=2)
pco.variances
round(pco.variances,3)
round(pco.variances,1)
sum(pco.variances)
pco.variances[plot.axis.1]
round(pco.variances[plot.axis.1],1)
Set PCO axes you want to plot (worth doing this as makes it easier later to plot different ones):#
plot.axis.1<-1#
plot.axis.2<-3#
#
# #
xlab<-paste("PC",plot.axis.1," (",round(pco.variances[plot.axis.1],1),"%)",sep="")#
ylab<-paste("PC",plot.axis.2," (",round(pco.variances[plot.axis.1],1),"%)",sep="")#
#
# First plot an empty ordination space:#
plot(pco[,plot.axis.1],pco[,plot.axis.2],type="n",xlab=,ylab=,main="Tree branches (lines) with tips (Xs) and root (O)")#
#
# For each branch in the tree:#
for(i in 1:length(lungfish.tree$edge.length)) {#
#
	# Find from value for branch:#
	from.row<-match(as.character(lungfish.tree$edge[i,1]),rownames(lungfish.Gower))#
	# If this is a terminal branch:#
	if(lungfish.tree$edge[i,2] <= Ntip(lungfish.tree)) {#
		# Find the tip label as text in the PCO matrix rownames:#
		to.row<-match(lungfish.tree$tip.label[lungfish.tree$edge[i,2]],rownames(lungfish.Gower))#
	# If this is an internal branch:#
	} else {#
		# Find the node label as a number in the PCO matrix rownames:#
		to.row<-match(as.character(lungfish.tree$edge[i,2]),rownames(lungfish.Gower))#
	}#
#
	# Set x and y values for line:#
	x<-c(pco[from.row,plot.axis.1],pco[to.row,plot.axis.1])#
	y<-c(pco[from.row,plot.axis.2],pco[to.row,plot.axis.2])#
#
	# Plot branch:#
	lines(x,y,col="grey",lwd=2)#
}#
#
# Plot root node:#
points(pco[match(as.character(Ntip(lungfish.tree)+1),rownames(pco)),plot.axis.1],pco[match(as.character(Ntip(lungfish.tree)+1),rownames(pco)),plot.axis.2],col="red",cex=2)#
#
# Plot tips only into ordination space as black Xs:#
points(pco[1:Ntip(lungfish.tree),plot.axis.1],pco[1:Ntip(lungfish.tree),plot.axis.2],pch=4,cex=2)#
#
# Add taxon names as text:#
text(pco[1:Ntip(lungfish.tree),plot.axis.1],pco[1:Ntip(lungfish.tree),plot.axis.2],rownames(pco)[1:Ntip(lungfish.tree)],cex=0.5)
xlab<-paste("PC",plot.axis.1," (",round(pco.variances[plot.axis.1],1),"%)",sep="")#
ylab<-paste("PC",plot.axis.2," (",round(pco.variances[plot.axis.1],1),"%)",sep="")#
#
# First plot an empty ordination space:#
plot(pco[,plot.axis.1],pco[,plot.axis.2],type="n",xlab=xlab,ylab=ylab,main="Tree branches (lines) with tips (Xs) and root (O)")#
#
# For each branch in the tree:#
for(i in 1:length(lungfish.tree$edge.length)) {#
#
	# Find from value for branch:#
	from.row<-match(as.character(lungfish.tree$edge[i,1]),rownames(lungfish.Gower))#
	# If this is a terminal branch:#
	if(lungfish.tree$edge[i,2] <= Ntip(lungfish.tree)) {#
		# Find the tip label as text in the PCO matrix rownames:#
		to.row<-match(lungfish.tree$tip.label[lungfish.tree$edge[i,2]],rownames(lungfish.Gower))#
	# If this is an internal branch:#
	} else {#
		# Find the node label as a number in the PCO matrix rownames:#
		to.row<-match(as.character(lungfish.tree$edge[i,2]),rownames(lungfish.Gower))#
	}#
#
	# Set x and y values for line:#
	x<-c(pco[from.row,plot.axis.1],pco[to.row,plot.axis.1])#
	y<-c(pco[from.row,plot.axis.2],pco[to.row,plot.axis.2])#
#
	# Plot branch:#
	lines(x,y,col="grey",lwd=2)#
}#
#
# Plot root node:#
points(pco[match(as.character(Ntip(lungfish.tree)+1),rownames(pco)),plot.axis.1],pco[match(as.character(Ntip(lungfish.tree)+1),rownames(pco)),plot.axis.2],col="red",cex=2)#
#
# Plot tips only into ordination space as black Xs:#
points(pco[1:Ntip(lungfish.tree),plot.axis.1],pco[1:Ntip(lungfish.tree),plot.axis.2],pch=4,cex=2)
plot(1:length(pco.variances),pco.variances,type="l")
plot(1:length(pco.variances),pco.variances,type="l",ylab="Percentage variance explained",xlab="PC Axis")
pco
Set PCO axes you want to plot (worth doing this as makes it easier later to plot different ones):#
plot.axis.1<-1#
plot.axis.2<-3
Make labels for x and y axes:#
xlab<-paste("PC",plot.axis.1," (",round(pco.variances[plot.axis.1],1),"%)",sep="")#
ylab<-paste("PC",plot.axis.2," (",round(pco.variances[plot.axis.1],1),"%)",sep="")
First plot an empty ordination space:#
plot(pco[,plot.axis.1],pco[,plot.axis.2],type="n",xlab=xlab,ylab=ylab,main="Tree branches (lines) with tips (Xs) and root (O)")
Make labels for x and y axes:#
xlab<-paste("PC",plot.axis.1," (",round(pco.variances[plot.axis.1],1),"%)",sep="")#
ylab<-paste("PC",plot.axis.2," (",round(pco.variances[plot.axis.2],1),"%)",sep="")#
#
# First plot an empty ordination space:#
plot(pco[,plot.axis.1],pco[,plot.axis.2],type="n",xlab=xlab,ylab=ylab,main="Tree branches (lines) with tips (Xs) and root (O)")
i<-1
Find from value for branch:#
	from.row<-match(as.character(lungfish.tree$edge[i,1]),rownames(lungfish.Gower))
from.row
lungfish.tree$edge
lungfish.tree$edge[i,2] <= Ntip(lungfish.tree)
match(lungfish.tree$tip.label[lungfish.tree$edge[i,2]],rownames(lungfish.Gower))
Find the tip label as text in the PCO matrix rownames:#
		to.row<-match(lungfish.tree$tip.label[lungfish.tree$edge[i,2]],rownames(lungfish.Gower))
to.row
Set x and y values for line:#
	x<-c(pco[from.row,plot.axis.1],pco[to.row,plot.axis.1])#
	y<-c(pco[from.row,plot.axis.2],pco[to.row,plot.axis.2])
x
y
Plot branch:#
	lines(x,y,col="grey",lwd=2)
peeps<-c("Tomasz Borszcz","Neil Brocklehurst","Aidan Couzens","Andrew Du","Daniel Field","Julieta Gallego","Derek Larson","Emily Orzechowski","Silvia Pineda-Munoz","Mark Puttick","Nadia Scott","Stephanie Smith","Davey Wright")
sample(peeps)
Get in the necessary functions:#
source("http://www.graemetlloyd.com/pubdata/functions_3.r")#
#
# Library:#
library(phytools)#
library(paleotree)#
#
# Read in a data matrix from my web site (pick a different one from this!):#
lungfish.matrix<-get.nexus("http://www.graemetlloyd.com/nexus/Lloyd_etal_2012a.nex")#
#
# Read in tree:#
lungfish.tree<-read.tree("http://www.graemetlloyd.com/firstmpt/Lloyd_etal_2012a.tre")#
#
# Read in ages:#
lungfish.ages<-read.table("~/Documents/Teaching/External/PaleoDB Summer Course 2013/daterr.txt",row.names=1)#
#
# Time-scale tree using equal method:#
lungfish.tree<-timePaleoPhy(lungfish.tree,lungfish.ages,type="equal",vartime=5)#
#
# Estimate ancestral state values:#
lungfish.ancestors<-anc.state.est.matrix(lungfish.matrix,lungfish.tree)
names(lungfish.matrix)
Rename ancestor rownames by descendant taxa that define them:#
for(j in 1:length(lungfish.ancestors[,1])) rownames(lungfish.ancestors)[j]<-paste(sort(lungfish.tree$tip.label[find.descendants(rownames(lungfish.ancestors)[j],lungfish.tree)]),collapse="%%")
Add ancestors into matrix:#
lungfish.matrix$matrix<-rbind(lungfish.matrix$matrix,lungfish.ancestors)
Get distance matrices:#
lungfish.distances<-dist.clad.matrix(lungfish.matrix)
Get Gower dissimilarity matrix:#
lungfish.Gower<-lungfish.distances$dist.matrix/lungfish.distances$comp.char.matrix
You can also rescale by the maximum possible observable distance instead:#
lungfish.Gower<-lungfish.distances$dist.matrix/lungfish.distances$max.dist.matrix#
diag(lungfish.Gower)<-0 # Need to replace diagonal with 0 to avoid NaN issue
Trim taxa that cause missing data:#
trim.out<-trim.clad.dist.matrix(lungfish.Gower,lungfish.tree)
Give complete distance matrix:#
lungfish.Gower<-trim.out$dist.matrix#
#
# Get corresponding tree:#
lungfish.tree<-trim.out$tree
Find node names:#
node.names<-rownames(lungfish.Gower)[grep("%%",rownames(lungfish.Gower))]#
for(j in 1:length(node.names)) names(node.names)[j]<-find.ancestor(strsplit(node.names[j],"%%")[[1]],lungfish.tree)#
rownames(lungfish.Gower)[match(node.names,rownames(lungfish.Gower))]<-names(node.names)#
colnames(lungfish.Gower)[match(node.names,colnames(lungfish.Gower))]<-names(node.names)
Perform principal coordinates on the data:#
pco<-cmdscale(lungfish.Gower,k=length(lungfish.Gower[,1])-1)
Get variance of pco axes:#
pco.variances<-apply(pco,2,var)/sum(apply(pco,2,var))*100
Plot variance of PCO axes:#
plot(1:length(pco.variances),pco.variances,type="l",ylab="Percentage variance explained",xlab="PC Axis")
Set PCO axes you want to plot (worth doing this as makes it easier later to plot different ones):#
plot.axis.1<-1#
plot.axis.2<-3
Make labels for x and y axes:#
xlab<-paste("PC",plot.axis.1," (",round(pco.variances[plot.axis.1],1),"%)",sep="")#
ylab<-paste("PC",plot.axis.2," (",round(pco.variances[plot.axis.2],1),"%)",sep="")
xlab
First plot an empty ordination space:#
plot(pco[,plot.axis.1],pco[,plot.axis.2],type="n",xlab=xlab,ylab=ylab,main="Tree branches (lines) with tips (Xs) and root (O)")
For each branch in the tree:#
for(i in 1:length(lungfish.tree$edge.length)) {#
#
	# Find from value for branch:#
	from.row<-match(as.character(lungfish.tree$edge[i,1]),rownames(lungfish.Gower))#
	# If this is a terminal branch:#
	if(lungfish.tree$edge[i,2] <= Ntip(lungfish.tree)) {#
		# Find the tip label as text in the PCO matrix rownames:#
		to.row<-match(lungfish.tree$tip.label[lungfish.tree$edge[i,2]],rownames(lungfish.Gower))#
	# If this is an internal branch:#
	} else {#
		# Find the node label as a number in the PCO matrix rownames:#
		to.row<-match(as.character(lungfish.tree$edge[i,2]),rownames(lungfish.Gower))#
	}#
#
	# Set x and y values for line:#
	x<-c(pco[from.row,plot.axis.1],pco[to.row,plot.axis.1])#
	y<-c(pco[from.row,plot.axis.2],pco[to.row,plot.axis.2])#
#
	# Plot branch:#
	lines(x,y,col="grey",lwd=2)#
}
Plot root node:#
points(pco[match(as.character(Ntip(lungfish.tree)+1),rownames(pco)),plot.axis.1],pco[match(as.character(Ntip(lungfish.tree)+1),rownames(pco)),plot.axis.2],col="red",cex=2)
Set PCO axes you want to plot (worth doing this as makes it easier later to plot different ones):#
plot.axis.1<-1#
plot.axis.2<-3#
#
# Make labels for x and y axes:#
xlab<-paste("PC",plot.axis.1," (",round(pco.variances[plot.axis.1],1),"%)",sep="")#
ylab<-paste("PC",plot.axis.2," (",round(pco.variances[plot.axis.2],1),"%)",sep="")#
#
# First plot an empty ordination space:#
plot(pco[,plot.axis.1],pco[,plot.axis.2],type="n",xlab=xlab,ylab=ylab,main="Tree branches (lines) with tips (Xs) and root (O)")#
#
# For each branch in the tree:#
for(i in 1:length(lungfish.tree$edge.length)) {#
#
	# Find from value for branch:#
	from.row<-match(as.character(lungfish.tree$edge[i,1]),rownames(lungfish.Gower))#
	# If this is a terminal branch:#
	if(lungfish.tree$edge[i,2] <= Ntip(lungfish.tree)) {#
		# Find the tip label as text in the PCO matrix rownames:#
		to.row<-match(lungfish.tree$tip.label[lungfish.tree$edge[i,2]],rownames(lungfish.Gower))#
	# If this is an internal branch:#
	} else {#
		# Find the node label as a number in the PCO matrix rownames:#
		to.row<-match(as.character(lungfish.tree$edge[i,2]),rownames(lungfish.Gower))#
	}#
#
	# Set x and y values for line:#
	x<-c(pco[from.row,plot.axis.1],pco[to.row,plot.axis.1])#
	y<-c(pco[from.row,plot.axis.2],pco[to.row,plot.axis.2])#
#
	# Plot branch:#
	lines(x,y,col="grey",lwd=2)#
}#
#
# Plot root node:#
points(pco[match(as.character(Ntip(lungfish.tree)+1),rownames(pco)),plot.axis.1],pco[match(as.character(Ntip(lungfish.tree)+1),rownames(pco)),plot.axis.2],col="red",cex=2)
Plot tips only into ordination space as black Xs:#
points(pco[1:Ntip(lungfish.tree),plot.axis.1],pco[1:Ntip(lungfish.tree),plot.axis.2],pch=4,cex=2)
Add taxon names as text:#
text(pco[1:Ntip(lungfish.tree),plot.axis.1],pco[1:Ntip(lungfish.tree),plot.axis.2],rownames(pco)[1:Ntip(lungfish.tree)],cex=0.5)
Get ape library:#
library(ape)#
#
# Read in an example tree:#
tree<-read.tree("http://www.graemetlloyd.com/firstmpt/Perez-Garcia_et_Murelaga_2012a.tre")
plot(tree)
Get ape library:#
library(ape)#
#
# Read in an example tree:#
tree<-read.tree("http://www.graemetlloyd.com/firstmpt/Perez-Garcia_et_Murelaga_2012a.tre")#
#
# Find descendants function:#
find.descendants<-function(n,tree)#
{#
	n<-as.vector(n)#
	ancs<-vector(mode="numeric")#
	desc<-vector(mode="numeric")#
	while (length(n) > 0) {#
		for (i in 1:length(n)) ancs<-c(tree$edge[grep(TRUE,tree$edge[,1] == n[i]),2],ancs)#
		n<-vector(mode="numeric")#
		for (i in length(ancs):1) {#
			if (ancs[i] <= Ntip(tree)) desc<-c(desc,ancs[i])#
			if (ancs[i] > Ntip(tree)) n<-c(n,ancs[i])#
			ancs<-ancs[-i]#
		}#
	}#
	return(desc)#
}
Create a matrix of zeroes #
	mrp<-matrix(0,ncol=(Nnode(tree)-1),nrow=Ntip(tree))#
#
	# Set rownames as tip labels:#
	rownames(mrp)<-tree$tip.label#
#
	# Set column names as node numbers (excluding root):#
	colnames(mrp)<-as.character(c((Ntip(tree)+2):(Ntip(tree)+Nnode(tree))))
mrp
for(j in (Ntip(tree)+2):(Ntip(tree)+Nnode(tree))) { }
For each non-root node:#
	for(i in colnames(mrp)) {}
i
find.descendants(i, tree)
find.descendants(as.numeric(i), tree)
Get descendant tip numbers:#
		tip.nos<-find.descendants(as.numeric(i), tree)
tip.nos
mrp[tree$tip.label[tip.nos],as.character(i)]
Get ape library:#
library(ape)#
#
# Read in an example tree:#
tree<-read.tree("http://www.graemetlloyd.com/firstmpt/Perez-Garcia_et_Murelaga_2012a.tre")#
#
# Find descendants function:#
find.descendants<-function(n,tree)#
{#
	n<-as.vector(n)#
	ancs<-vector(mode="numeric")#
	desc<-vector(mode="numeric")#
	while (length(n) > 0) {#
		for (i in 1:length(n)) ancs<-c(tree$edge[grep(TRUE,tree$edge[,1] == n[i]),2],ancs)#
		n<-vector(mode="numeric")#
		for (i in length(ancs):1) {#
			if (ancs[i] <= Ntip(tree)) desc<-c(desc,ancs[i])#
			if (ancs[i] > Ntip(tree)) n<-c(n,ancs[i])#
			ancs<-ancs[-i]#
		}#
	}#
	return(desc)#
}#
#
# MRP function#
MRP<-function(tree) {#
#
	# require the ape library:#
	require(ape)#
#
	# Create a matrix of zeroes #
	mrp<-matrix(0,ncol=(Nnode(tree)-1),nrow=Ntip(tree))#
#
	# Set rownames as tip labels:#
	rownames(mrp)<-tree$tip.label#
#
	# Set column names as node numbers (excluding root):#
	colnames(mrp)<-as.character(c((Ntip(tree)+2):(Ntip(tree)+Nnode(tree))))#
#
	# For each non-root node:#
	for(i in colnames(mrp)) {#
		# Get descendant tip numbers:#
		tip.nos<-find.descendants(as.numeric(i), tree)#
		# Code descendants of node as 1:#
		mrp[tree$tip.label[tip.nos],as.character(i)]<-1#
	}#
	# Return MRP matrix:#
	return(mrp)#
}#
#
MRP(tree)
Get ape library:#
library(ape)#
#
# Read in an example tree:#
tree<-read.tree("http://www.graemetlloyd.com/firstmpt/Perez-Garcia_et_Murelaga_2012a.tre")
Find descendants function:#
find.descendants<-function(n,tree)#
{#
	n<-as.vector(n)#
	ancs<-vector(mode="numeric")#
	desc<-vector(mode="numeric")#
	while (length(n) > 0) {#
		for (i in 1:length(n)) ancs<-c(tree$edge[grep(TRUE,tree$edge[,1] == n[i]),2],ancs)#
		n<-vector(mode="numeric")#
		for (i in length(ancs):1) {#
			if (ancs[i] <= Ntip(tree)) desc<-c(desc,ancs[i])#
			if (ancs[i] > Ntip(tree)) n<-c(n,ancs[i])#
			ancs<-ancs[-i]#
		}#
	}#
	return(desc)#
}
MRP function#
MRP<-function(tree) {#
#
	# require the ape library:#
	require(ape)#
#
	# Create a matrix of zeroes #
	mrp<-matrix(0,ncol=(Nnode(tree)-1),nrow=Ntip(tree))#
#
	# Set rownames as tip labels:#
	rownames(mrp)<-tree$tip.label#
#
	# Set column names as node numbers (excluding root):#
	colnames(mrp)<-as.character(c((Ntip(tree)+2):(Ntip(tree)+Nnode(tree))))#
#
	# For each non-root node:#
	for(i in colnames(mrp)) {#
		# Get descendant tip numbers:#
		tip.nos<-find.descendants(as.numeric(i), tree)#
		# Code descendants of node as 1:#
		mrp[tree$tip.label[tip.nos],as.character(i)]<-1#
	}#
	# Return MRP matrix:#
	return(mrp)#
}
Return MRP matrix for tree:#
MRP(tree)
c<-runif(20,1,10)
c
x<-runif(20,1,10)
dist(x)
Get functions in:#
source("http://www.graemetlloyd.com/pubdata/functions_3.r")#
#
# Set working directory:#
setwd("/Users/gral")#
#
# Get list of mrp files:#
mrp.list<-list.files()[grep("mrp.nex",list.files())]#
#
# Get list of mrp files:#
trees.list<-list.files()[grep("mpts_plus_strict.nex",list.files())]#
#
# Make tree files:#
for(i in 1:length(trees.list)) {#
	mytrees<-trees.to.mpts.plus.strict(trees.list[i])#
	file.name<-gsub("tntmpts_plus_strict.nex","",trees.list[i])#
	write(mytrees$mpts, paste("/Users/gral/Documents/Homepage/www.graemetlloyd.com/mpts","/",file.name,".tre",sep=""))#
	write(mytrees$mpts[1], paste("/Users/gral/Documents/Homepage/www.graemetlloyd.com/firstmpt","/",file.name,".tre",sep=""))#
	write(mytrees$strict, paste("/Users/gral/Documents/Homepage/www.graemetlloyd.com/sc","/",file.name,".tre",sep=""))#
	print(paste("http://supfam.cs.bris.ac.uk/TreeVector/cgi-bin/maketree.cgi?topology=",gsub(";","%3B",gsub(")","%29",gsub("\\(","%28",mytrees$strict))),"&treetype=-clad",sep=""))#
}
Get functions and libraries in:#
source("http://www.graemetlloyd.com/pubdata/functions_4.r")#
#
# Read in trees:#
mpts<-read.tree("~/Dropbox/Bayesian_treedates/Rates data and code/Osteoglossomorpha/mpts.tre")#
#
# Read in taxon ages:#
ages<-read.table("~/Dropbox/Bayesian_treedates/Rates data and code/Osteoglossomorpha/ages.txt",sep=",",row.names=1)#
tip.ages<-c(ages[,1])#
names(tip.ages)<-rownames(ages)#
#
# Sequence, following Patterson (1977), Rosen & Patterson (1977), Arratia (1997), and Arratia & Tischlinger (2010): Holostei (Watsonulus eugnathoides), Elpistoichthys pectinatus, Pholidophorus higginsi, Pholidophorus bechei, Pholidolepis dorsetensis, Leptolepis coryphaenoides, Ichthyodectiformes (Occithrissops), Elopomorpha (Anaethalion), Otocephala (Tischlingerichthys)#
outgroup.ages<-c(275.6, 216.5, 199.6, 192.6, 192.6 , 180, 164.7, 150.8, 145.5)# Hard upper bound, from Hurley et al. (2007) - Discoserra pectinodon:#
t0<-318.1#
#
# Number of replicates:#
resolution<-1000# Date each MPT:for(i in 1:length(mpts)) {	tree<-mpts[[i]]	out<-Hedman.tree.dates(tree, tip.ages, outgroup.ages, t0, resolution, conservative=TRUE)#
	mpts[[i]]<-out$tree}#
#
write.tree(mpts,"~/Dropbox/Bayesian_treedates/Rates data and code/Osteoglossomorpha/ttrees.tre")
objects()
library(phytools)#
#
x<-matrix(c(1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1),ncol=2)#
rownames(x)<-c("Acanthodes","Ctenacanthus","Dicksonosteus","Cheirolepis","Osorioichthys","Howqualepis","Mimia","Moythomasia","Dialipina","Ligulalepis","Meemannia","Psarolepis","Styloichthys","Kenichthys","Powichthys","Diabolepis","Youngolepis","Miguashaia","Onychodus")#
colnames(x)<-c(0,1)#
#
tree<-read.tree(text="(Acanthodes:1,(Ctenacanthus:1,(Dicksonosteus:1,(((Cheirolepis:1,(Osorioichthys:1,(Howqualepis:1,(Mimia:1,Moythomasia:1):1):1):1):1,(Dialipina:1,Ligulalepis:1):1):1,(Meemannia:1,(Psarolepis:1,((Styloichthys:1,(Kenichthys:1,(Powichthys:1,(Diabolepis:1,Youngolepis:1):1):1):1):1,(Miguashaia:1,Onychodus:1):1):1):1):1):1):1):1);")#
#
mymodel<-"ER"#
#
rerootingMethod(tree, x, mymodel)
library(phytools)
rerootingMethod
library(phytools)
packageVersion("phytools")
library(paleotree)
library(geiger)
?node.leaves
geo=get(data(geospiza))#
#
tips(geo$phy, 18)
find.descendants()
library(strap)
find.descendants
tree<-rtree(20)
tree
find.descendants(tree, 24)
find.descendants(24, tree)
tree$tip.label[find.descendants(24, tree)]
Get in my functions:#
source("http://www.graemetlloyd.com/pubdata/functions_3.r")#
#
# Get in Claddis functions:#
setwd("~/Documents/Publications/in prep/Claddis/Claddis/R")#
file.list<-list.files()#
for(i in file.list) source(i)#
#
# Get in paleotree library:#
library(paleotree)#
#
# Read in matrix:#
clad.matrix<-get.nexus("http://www.graemetlloyd.com/nexus/Choiniere_etal_inpressba.nex")#
#
# Read in tree:#
tree<-read.tree("http://www.graemetlloyd.com/firstmpt/Choiniere_etal_inpressba.tre")
